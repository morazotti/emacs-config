#+title: Emacs init
#+author: nmorazotti
#+email: nicolas.morazotti@protonmail.ch
#+TODO: TODO(t) IN-PROGRESS(p) | DONE(d) ABANDONED(b)
#+STARTUP: overview
Atualizando e organizando minha config.

* custom-file
#+begin_src emacs-lisp :tangle init.el
(setq custom-file "~/.config/emacs/custom.el")
#+end_src

#+RESULTS:
: ~/.config/emacs/custom.el

* =package=
Carregar o package, adicionar o melpa, carregar =common-lisp=.

#+begin_src emacs-lisp :tangle init.el 
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  (package-initialize)
#+end_src

#+RESULTS:
  
#+begin_src emacs-lisp :tangle init.el 
  (require 'cl-lib)
  (setq warning-minimum-log-level :error)
#+end_src

#+RESULTS:
: :error

* =use-package=

=Boostrap=  do =use-package= para auto-instalar a configuração inteira
sozinho.

#+begin_src emacs-lisp :tangle init.el 
  (unless (package-installed-p 'use-package) 
  (package-refresh-contents)
  (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
  (setq use-package-always-defer t) 
#+end_src

#+RESULTS:
: t

* =straight.el=
O =straight.el= é um package-manager que permite o uso de repositórios
=git= para maior flexibilidade.
#+begin_src emacs-lisp :tangle init.el 
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
  (setq straight-use-package-by-default t)
  (setq straight-disable-byte-compilation t)
#+end_src

#+RESULTS:
: t
* =org=
=org= precisa ser rapidamente carregado para não conflitar com outras coisas.
#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :straight (:type built-in))
#+end_src
** =ox-extra=
Adiciona algumas funcionalidades novas para o org-export, como utilizar
a /headline/ =ignore= para pular a headline sem pular o texto dela na exportação..
#+begin_src emacs-lisp :tangle init.el 
  (use-package org
    :init 
    (defun display-ansi-colors ()
      "Fixes kernel output in emacs-jupyter"
      (ansi-color-apply-on-region (point-min) (point-max)))
    :hook (org-mode . my/sane-heading-size)
    :hook (org-mode . org-indent-mode)
    :hook (org-mode . auto-fill-mode)
    :config (setq org-preview-latex-image-directory "/home/nicolas/.cache/ltximg/")
    ;; :defer 7 ; estava ativo, não sei se mantenho
    :bind (:map org-mode-map ("<f7>" . 
                              (lambda()
                                (interactive)
                                (org-export-dispatch 1)))))
  (add-hook 'org-babel-after-execute-hook #'display-ansi-colors)
  (use-package org-contrib)
  (require 'ox-extra)
  (ox-extras-activate '(latex-header-blocks ignore-headlines))
#+end_src

#+RESULTS:
A função que mantém os /headings/ do =org-mode= constantes:
#+begin_src emacs-lisp :tangle init.el 
  (defun my/sane-heading-size ()
    (dolist
        (face '(org-level-1
                org-level-2
                org-level-3
                org-level-4
                org-level-5
                org-document-title))
      (set-face-attribute face nil :weight 'normal :height 1.0)))
#+end_src

Quero ser capaz de utilizar alguma sintaxe para exportar subfiguras em
LaTeX.
#+begin_src emacs-lisp :tangle init.el
  (org-link-set-parameters
   "subfig"
   :follow (lambda (file) (find-file file))
   :face '(:foreground "chocolate" :weight bold :underline t)
   :display 'full
   :export (lambda (file desc backend)
             (when (eq backend 'latex)
               (if (string-match ">(\\(.+\\))" desc)
                   (concat "\\subfigure[" (replace-regexp-in-string "\s+>(.+)" "" desc) "]"
                           "{\\includegraphics"
                           "["
                           (match-string 1 desc)
                           "]"
                           "{"
                           file
                           "}}")
                 (format "\\subfigure[%s]{\\includegraphics{%s}}" desc file)))))
#+end_src

Seu uso é feito da seguinte maneira:
#+begin_example 
  #+name: fig_name
  #+attr_latex: :options \centering
  #+caption: Figure Caption
  #+begin_figure 
  [[subfig:img1.png][Subcaption 1 >(scale=0.6)]] 
  [[subfig:img2.png][Subcaption 2 >(scale=0.6)]]
  [[subfig:img3.png][Subcaption 3 >(scale=0.6)]]
      #+end_figure
#+end_example
** async
Para utilizar =org-export= assíncrono, temos esse arquivo de inicialização:
#+begin_src emacs-lisp :tangle init-async.el
   ; Source - https://superuser.com/a
   ; Posted by T. Verron
   ; Retrieved 2025-12-05, License - CC BY-SA 3.0
   
   (require 'package)
   (setq package-enable-at-startup nil)
   (package-initialize)

   (require 'org) 
   (require 'ox)
   (require 'cl)  
   (setq org-export-async-debug nil)
#+end_src
#+begin_src emacs-lisp :tangle init.el
  (setq org-export-async-init-file (concat user-emacs-directory "init-async.el"))
#+end_src
** custom emphasis
Adiciona uma ênfase customizada para o org-mode, que traduz
palavra para fonte em negrito e vermelho.
#+begin_src emacs-lisp :tangle init.el
  ;; Adiciona uma nova entrada para `!` no `org-emphasis-alist`
  (add-to-list 'org-emphasis-alist
               '(! (:weight bold :foreground "red")))

  ;; Atualiza as regexes de ênfase para incluir o novo delimitador `!`
  (org-set-emph-re 'org-emphasis-regexp-components
                   '(" \t('\"{"
                     "- \t.,:!?;'\")}\\["
                     " \t\r\n,\"'"
                     "."
                     1))

  ;; Atualiza o modo org para usar as novas configurações de ênfase
  (org-element-update-syntax)

  ;; Atualiza as palavras-chave de font-lock
  (font-lock-add-keywords 'org-mode
                          '(("\\(!\\)\\([^!]+\\)\\(!\\)"
                             (1 '(:foreground "red" :weight bold) t)
                             (2 '(:foreground "red" :weight bold) 
                             (3 '(:foreground "red" :weight bold) t)))))

#+end_src

#+RESULTS:

** custom ox-extra
Aqui, há uma parte do código que converte =!palavra!= para
=\textcolor{red}{palavra}=
#+begin_src emacs-lisp :tangle init.el
  (defun my-org-latex-filter (text backend info)
    "Replace !word! with \\textcolor{red}{word} in LaTeX export."
    (when (org-export-derived-backend-p backend 'latex)
      (replace-regexp-in-string "!\\(.*?\\)!" "\\\\textcolor{red}{\\1}" text)))

  (add-to-list 'org-export-filter-plain-text-functions
               'my-org-latex-filter)
#+end_src
#+RESULTS:
| my-org-latex-filter |

** COMMENT =julia=
#+begin_src emacs-lisp :tangle init.el
  (use-package ob-julia
    :straight (:host github :repo "gjkerns/ob-julia" :branch "master")
    :config (setq inferior-julia-program-name "/usr/bin/julia"))
#+end_src

** =jupyter=

Bloco de =jupyter= para executar =python=. 
#+begin_src emacs-lisp :tangle init.el 
  (use-package jupyter
    :init (setq org-image-actual-width 1024)

    ;; preciso fixar o commit, deu problema ano passado
    :straight
    (:host github
           :repo "emacs-jupyter/jupyter"
           :branch "master"
           :commit "f97f4b5d8c83e0b901020f835183dde8a2bf649e"
           )

    :bind ("C-M-s-h" . jupyter-org-hydra/body)
    ;; isso permite o tamanho da imagem ser controlado por #+attr_*
    :config (require 'jupyter-julia)
            (require 'jupyter-python))
#+end_src

#+RESULTS:
: jupyter-org-hydra/body
** =ob-jupyter= em kernel externo
Para acessar o diretório com kernel disponível pelo ~jupyter kernel~
em uma máquina com acesso ~ssh~, podemos utilizar a opção
~:session
[/ssh:[USER@]HOST:]$HOME/.local/share/jupyter/runtime/kernel-<PID>.json~. Contudo,
isso é complicado de escrever, o PID muda sempre que abrirmos um
kernel novo, então dá um trabalhão. Para isso, o [[https://sqrtminusone.xyz/posts/2021-05-01-org-python/][sqrtminusone]] criou um
script que faz isso automaticamente em ~elisp~.

#+begin_src emacs-lisp :tangle init.el
  (defun my/choose-ssh-host (ssh-config-file)
    "Read SSH config file and allow the user to choose a host.
      If the chosen host is not 'localhost', prefix it with '/ssh:<chosen-host>:'."
    (let ((hosts '("localhost"))
      	(kern-dir "~/.local/share/jupyter/runtime/"))  ;; Add the "local" option to the hosts list
      ;; Read the SSH config file
      (with-temp-buffer
        (insert-file-contents ssh-config-file)
        ;; Use regex to find "Host" definitions
        (while (re-search-forward "^Host\\s-+\\(.*\\)" nil t)
          (push (match-string 1) hosts)))
      ;; Use completing-read to select a host
      (let ((chosen-host (completing-read "Choose SSH host: " (reverse hosts))))
        (if (string= chosen-host "localhost")
            (message kern-dir)
          (message (concat "/ssh:" chosen-host ":" kern-dir))))))

  (defun my/jupyter-runtime-folder ()
    (interactive)
    (expand-file-name (my/choose-ssh-host "~/.ssh/config"))) 

  (defun my/get-open-ports ()
    (mapcar
     #'string-to-number
     (split-string (shell-command-to-string "ss -tulpnH | awk '{print $5}' | sed -e 's/.*://'") "\n")))

  (defun my/list-jupyter-kernel-files ()
    (interactive)
    (mapcar
     (lambda (file) (cons (car file) (cdr (assq 'shell_port (json-read-file (car file))))))
     (sort
      (directory-files-and-attributes (my/jupyter-runtime-folder) t ".*kernel")
      (lambda (x y) (not (time-less-p (nth 6 x) (nth 6 y)))))))

  (defun my/select-jupyter-kernel ()
    (let ((ports (my/get-open-ports))
          (files (my/list-jupyter-kernel-files)))
      (completing-read
       "Jupyter kernels: " files)))
  ;; (seq-filter
  ;;  (lambda (file)
  ;;    (member (cdr file) ports))
  ;;  files))))

  (defun my/insert-jupyter-kernel ()
    "Insert a path to an active Jupyter kernel into the buffer"
    (interactive)
    (insert (my/select-jupyter-kernel)))

  (defun my/jupyter-connect-repl ()
    "Open emacs-jupyter REPL, connected to a Jupyter kernel"
    (interactive)
    (jupyter-connect-repl (my/select-jupyter-kernel) nil nil nil t))

  (defun my/jupyter-qtconsole ()
    "Open Jupyter QtConsole, connected to a Jupyter kernel"
    (interactive)
    (start-process "jupyter-qtconsole" nil "setsid" "jupyter" "qtconsole" "--existing"
                   (file-name-nondirectory (my/select-jupyter-kernel))))

  (defun my/jupyter-cleanup-kernels ()
    (interactive)
    (let* ((ports (my/get-open-ports))
           (files (my/list-jupyter-kernel-files))
           (to-delete (seq-filter
                       (lambda (file)
                         (not (member (cdr file) ports)))
                       files)))
      (when (and (length> to-delete 0)
                 (y-or-n-p (format "Delete %d files?" (length to-delete))))
        (dolist (file to-delete)
          (delete-file (car file))))))

  (defun my/jupyter-launch-local-kernel ()
    (interactive)
    (let* ((venv (concat (getenv "VIRTUAL_ENV") ".venv/" ))
  	 (process-environment process-environment)
  	 (venv-string (concat "VIRTUAL_ENV=" venv))
  	 (jupyter-bin (format "%sbin/jupyter" venv))
  	 (cmd-kernelspec-list (format "%s %s kernelspec list" venv-string jupyter-bin))
  	 (kernel-and-location
  	  (completing-read "Choose kernel: "
  			   (seq-remove #'string-empty-p (mapcar 'string-trim-left (cdr (split-string (shell-command-to-string cmd-kernelspec-list) "\n"))))
  			   nil t))
  	 (kernel
  	  (when (string-match "\\([a-zA-Z0-9\-.]+\\) *\\(.*\\)" kernel-and-location)
  	    (match-string 1 kernel-and-location)))
  	 (command `(,jupyter-bin "kernel" "--kernel" ,kernel)))
      (make-process :name "virtual-jupyter"
  		  :buffer "*Jupyter Kernel*"
  		  :command command)))
         #+end_src

#+RESULTS:
: my/jupyter-launch-local-kernel

Podemos colocar também no cabeçalho a linha
~#+property: header-args:jupyter-python :session [/ssh:[USER@]HOST:]$HOME/.local/share/jupyter/runtime/kernel-<PID>.json~
para inicializar todos os blocos ~jupyter-python~ com essa sessão.
** =tmux=
Permite o uso de =tmux= como execução iterativa de =shell= no
=org-babel=.
#+begin_src emacs-lisp :tangle init.el
  (use-package ob-tmux)
    ;; :config  (setq org-babel-tmux-terminal "/home/nicolas/.local/bin/ob-vterm")
    ;;          (setq org-babel-tmux-terminal-opts nil))
#+end_src

#+RESULTS:
: t

** =babel-mermaid=
O =mermaid= gera um flowchart melhor que o ditaa.
#+begin_src emacs-lisp :tangle init.el
   (use-package ob-mermaid
     :init (setq ob-mermaid-cli-path "/usr/local/bin/mmdc")
     (setq org-babel-default-header-args:mermaid
           (cons
            '(:pupeteer-config-file . "/home/nicolas/.local/src/pupeteer.json")
            (assq-delete-all :pupeteer-config-file
                             org-babel-default-header-args))))
#+end_src

#+RESULTS:
: ((:pupeteer-config-file . /home/nicolas/.local/src/pupeteer.json) (:session . none) (:results . replace) (:exports . code) (:cache . no) (:noweb . no) (:hlines . no) (:tangle . no))


** =org-transclude=
Funciona como a citação de arquivos do obsidian com =![[nota]]=. Uso:
=#+transclude: [[link para arquivo ]]:<properties>= 
#+begin_src emacs-lisp :tangle init.el
    (use-package org-transclusion)
#+end_src

#+RESULTS:
| org-transclusion-mode | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | #[0 \205 \301 \205 \302\303\301 !\304P!\305!\205 \306!\262\207 [org-ctags-enabled-p buffer-file-name expand-file-name file-name-directory /TAGS file-exists-p visit-tags-table] 3] | #[0 \305\306	>\203 \307 |

** =org-pomodoro=
Preparando horários melhores para pomodoro.
#+begin_src emacs-lisp :tangle init.el
  (use-package org-pomodoro
    :config (setq org-pomodoro-length 50
                  org-pomodoro-short-break-length 10))
#+end_src

#+RESULTS:
: t

** =org= babel
=org-babel= estende a funcionalidade do =org= para permitir execução de
blocos de código. Vou escolher as linguagens aqui.
#+begin_src emacs-lisp :tangle init.el 
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((C . t)
     (jupyter . t)
     (shell . t)
     (js . t)
     (julia . t)
     (tmux . t)
     (mermaid . t)
     ; (nextflow . t)
     ; (octave , t)
     (latex . t)
     (fortran . t)
     (python . t)
     (ledger . t)))
#+end_src

#+RESULTS:

** =roam=
=org-roam= é um segundo cérebro em =org-mode= que utilizo.
#+begin_src emacs-lisp :tangle init.el 
  (use-package org-roam
    :straight (:host github :repo "org-roam/org-roam" :branch "main")
    :hook
    (after-init . org-roam-db-autosync-mode)
    :init (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory "~/Documents/roam/")
    (org-roam-dailies-directory "~/Documents/roam/projeto-pessoal")
    (org-roam-graph-link-hidden-types ("files" "https" "ref" "fuzzy"))
    :bind (("C-c r f" . org-roam-node-find)
           ("C-c r c" . org-roam-capture)
           ("C-c r b" . org-roam-buffer-toggle)
           ("C-c r I" . org-roam-node-insert-immediate)
           :map org-mode-map
           (("C-c r i" . org-roam-node-insert))))
#+end_src

#+RESULTS:
: org-roam-node-insert

Para inserir um nó sem abri-lo (como na /keychord/ =C-c r I=),
precisamos dessa função.
#+begin_src emacs-lisp :tangle init.el
  (defun org-roam-node-insert-immediate (arg &rest args)
    (interactive "P")
    (let ((args (cons arg args))
          (org-roam-capture-templates
           (list (append (car org-roam-capture-templates)
                         '(:immediate-finish t)))))
      (apply #'org-roam-node-insert args)))
#+end_src

*** =org-roam-ui=
Uma interface gráfica para =org-roam= em [[https://localhost:35901]].

#+begin_src emacs-lisp :tangle init.el
  (use-package org-roam-ui
    :straight
      (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
      :after org-roam
      :config
      (setq org-roam-ui-sync-theme t
            org-roam-ui-follow t
            org-roam-ui-update-on-save t)
      :init (org-roam-ui-mode)

      ;; para compilar  
      :init (setq org-roam-ui-latex-macros
                  '(("\\Tr" . "\\mathrm{Tr}")
                    ("\\tr" . "\\mathrm{Tr}")
                    ("\\dyad" . "\\ket{#1}\\bra{#2}")
                    ("\\order" . "\\mathcal{O}({#1})")
                    ("\\I" . "\\mathbb{I}")
                    ("\\norm" . "\\parallel{#1}\\parallel")
                    ("\\id" . "\\mathbb{I}")
                    ("\\expval" . "\\langle{#1}\\rangle")
                    ("\\dd" . "\\mathrm{d}")
                    ("\\op" . "|{#1}\\rangle\\langle{#2}|")
                    ("\\label" . "\\vphantom")
                    ("\\dv" . "\\frac{\\mathrm{d}{#1}}{\\mathrm{d}{#2}}")
                    ("\\olra" . "\\overleftrightarrow{#1}"))))
  (setq org-roam-ui-open-on-start nil)
#+end_src

#+RESULTS:

** IN-PROGRESS =delve=
Delve é um /dashboard/ para caracterizar alguns arquivos seguindo a
metodologia de notas que eu estava olhando. Não tenho certeza ainda.
#+begin_src emacs-lisp :tangle init.el
  (use-package delve
    :straight (:repo "publicimageltd/delve"
                     :host github
                     :type git)
    :after (org-roam)
    ;; this is necessary if use-package-always-defer is true
    :demand t
    :bind
    ;; the main entry point, offering a list of all stored collections
    ;; and of all open Delve buffers:
    (("<f12>" . delve))
    :config
    ;; set meaningful tag names for the dashboard query
    (setq delve-dashboard-tags '("vida" "trabalho" "ilustracao"))
    ;; optionally turn on compact view as default
    (add-hook #'delve-mode-hook #'delve-compact-view-mode)
    ;; turn on delve-minor-mode when Org Roam file is opened:
    (delve-global-minor-mode))
#+end_src

#+RESULTS:
: delve

Estou finalmente entendendo como ele funciona. Estou gostando.
** =org-ref=
Referências a-la \LaTeX /no org-mode/!  A maior parte das configurações
eram importantes no doutorado, mas vou manter a maioria das coisas aqui.
#+begin_src emacs-lisp :tangle init.el
  (setq reftex-default-bibliography '("~/Dropbox/referencias.bib")
        bibtex-completion-bibliography "~/Dropbox/referencias.bib"
        org-cite-global-bibliography "~/Dropbox/referencias.bib"
        bibtex-completion-notes-path "~/Documents/roam/"
        citar-notes-paths '("~/Documents/roam/")
        bibtex-completion-library-path "~/Documents/my_lib/pdfs/"
        org-latex-listings 'minted
        ;; org-latex-packages-alist '(("" "minted" "bbm") ("" "physics" t) ("AUTO" "babel" t ("pdflatex" "xelatex" "lualatex")))
        org-latex-packages-alist '(("" "physics" t) ("" "tikz" t))
        org-latex-pdf-process '("latexmk -shell-escape -bibtex -interaction=nonstopmode -f -pdfxe -8bit %f")
        org-latex-prefer-user-labels t
        org-src-fontify-natively t
        org-confirm-babel-evaluate nil
        org-format-latex-options '(:foreground default
                                               :background default
                                               :scale 2.0
                                               :html-foreground "Black"
                                               :html-background "Transparent"
                                               :html-scale 1.0
                                               :matchers ("begin" "$1" "$" "$$" "\\(" "\\[" ))
        org-src-window-setup 'reorganize-frame)
#+end_src

#+RESULTS:
: reorganize-frame

#+begin_src emacs-lisp :tangle init.el 
  (use-package org-ref
    :hook (org-mode . (lambda () (require 'org-ref)))
    ;; :init (require 'org-ref-ivy)
    ;; :config (require 'org-ref-ivy)
    ;; (load-file "~/.config/emacs/straight/build/org-ref/org-ref-ivy.el") ;; talvez nao precise
    :config 
              (setq org-file-apps '((auto-mode . emacs)
                                    (directory . emacs)
                                    (\.mm\' . default)
                                    (\.x?html?\' . default)
                                    (\.pdf\' . emacs)))

    ;; agora que terminei o doutorado, acho que isso aqui não vai ser importante.
    ;; :config (add-to-list 'org-latex-classes
    ;;                      '("uspsc"
    ;;                        "\\documentclass{USPSC-classe/USPSC}"
    ;;                        ("\\chapter{%s}" . "\\chapter*{%s}")
    ;;                        ("\\section{%s}" . "\\section*{%s}")
    ;;                        ("\\subsection{%s}" . "\\subsection*{%s}")
    ;;                        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
    ;;                        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
    :bind (("C-c C-]" . org-ref-insert-link)
           ("C-c )" . org-ref-insert-ref-link)))
#+end_src

#+RESULTS:
: org-ref-insert-ref-link

Para utilizar =org-roam= e =org-ref= em conjunto, precido do
=org-roam-bibtex=. Ele permite criar notas de pdfs diretamente no
=org-roam=.
#+begin_src emacs-lisp :tangle init.el
    (use-package biblio)
#+end_src
#+begin_src emacs-lisp :tangle init.el
  (use-package org-roam-bibtex
    :ensure t
    :after (org-roam)
    :load-path "~/Documents/roam/" 
    :config (require 'org-ref)
    :init (org-roam-bibtex-mode))
#+end_src

** =org-agenda=
=org-agenda= é uma poderosa agenda que utiliza todos os arquivos
selecionados para organizar o dia-a-dia.
#+begin_src emacs-lisp :tangle init.el 
  (setq org-directory "/home/nicolas/Documents/org")
  (setq org-default-notes-file (concat org-directory "/notes.org"))
  (setq org-agenda-files (list (concat org-directory "/tasks.org")
                               (concat org-directory "/opusdei.org")
                               ;; (concat org-directory "/media.org")
                               ;; (concat org-directory "/planodevida.org")
                               ;; (concat org-directory "/notes.org")
                               ))
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c a") 'org-agenda)
#+end_src

#+RESULTS:
: org-agenda

Com calfw e calfw-org, temos uma visão de calendário do nosso
org-agenda -- como os spreads de um bullet journal.

#+begin_src emacs-lisp :tangle init.el
  (use-package calfw)
  (use-package calfw-org)
  (require 'calfw-org)
#+end_src

Essa agenda aqui tem algumas informações a mais que a agenda padrão do emacs.
#+begin_src emacs-lisp :tangle init.el 
   (defun air-org-skip-subtree-if-priority (priority)
     "Skip an agenda subtree if it has a priority of PRIORITY.

   PRIORITY may be one of the characters ?A, ?B, or ?C."
     (let ((subtree-end (save-excursion (org-end-of-subtree t)))
           (pri-value (* 1000 (- org-lowest-priority priority)))
           (pri-current (org-get-priority (thing-at-point 'line t))))
       (if (= pri-value pri-current)

           subtree-end
         nil)))
     (setq org-agenda-custom-commands
           '(("c" "Simple agenda view"
              ((tags "PRIORITY=\"A\""
                     ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                      (org-agenda-overriding-header "High-priority unfinished tasks:")))
               (agenda "")
               (alltodo ""((org-agenda-skip-function
                        '(or (air-org-skip-subtree-if-priority ?A)
                             (org-agenda-skip-if nil '(scheduled deadline))))))))
             ("p" "Planning" ((tags-todo "+@planning-@work")
                              (todo "BACKLOG" )))
             ("u" "Untagged Tasks" ((tags-todo "-{.*}" ((org-agenda-overriding-header "Untagged Tasks")))
                                    (todo ".*" ((org-agenda-files '("~/Documents/org/notes.org"))
                                                (org-agenda-overriding-header "Inbox"))))) 
             ("w" "Work" ((tags-todo "+@work" ((org-agenda-overriding-header "Work Tasks")))
                          (agenda "" ((org-agenda-overriding-header "Work Agenda")
                                      (org-agenda-files '("~/Documents/org/tasks.org"))
                                      (org-agenda-skip-entry-if 'notscheduled 'notdeadline)
                                      (org-agenda-span 'week)))))))
#+end_src

#+RESULTS:
| c | Simple agenda view | ((tags PRIORITY="A" ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done)) (org-agenda-overriding-header High-priority unfinished tasks:))) (agenda ) (alltodo  ((org-agenda-skip-function '(or (air-org-skip-subtree-if-priority 65) (org-agenda-skip-if nil '(scheduled deadline))))))) |
| p | Planning           | ((tags-todo +@planning-@work) (todo BACKLOG))                                                                                                                                                                                                                                                          |
| u | Untagged Tasks     | ((tags-todo -{.*} ((org-agenda-overriding-header Untagged Tasks))) (todo .* ((org-agenda-files '(~/Documents/org/notes.org)) (org-agenda-overriding-header Inbox))))                                                                                                                                   |
| w | Work               | ((tags-todo +@work ((org-agenda-overriding-header Work Tasks))) (agenda  ((org-agenda-overriding-header Work Agenda) (org-agenda-files '(~/Documents/org/blackgenn.org)) (org-agenda-skip-entry-if 'notscheduled 'notdeadline) (org-agenda-span 'week))))                                              |

*** COMMENT =super-agenda=
=org-super-agenda= parece bastante útil, mas não tenho nada
configurado. Ver [[https://github.com/alphapapa/org-super-agenda/blob/master/examples.org#feature-examples][aqui]].
#+begin_src emacs-lisp :tangle init.el
  (use-package org-super-agenda
    :init (org-super-agenda-mode 1)
    ;; :init (setq initial-buffer-choice (lambda () (get-buffer "*Org Agenda*")))
    ;; organização por grupos utilizando a propriedade =:agenda-group:=
    :config (setq org-super-agenda-groups
                '(
                  (:auto-property "ProjectId")

                  ;; (:name "blackgenn"
                  ;;        :scheduled today)
                  (:name "emacs" :tag "emacs")
                  (:name "books"
                         :and (:tag "book")))))
#+end_src

#+RESULTS:
: t

** org-notifications
Tem como notificar-me de acordo com o estado das coisas utilizando
apenas o appt.
#+begin_src emacs-lisp :tangle init.el
  (setq appt-message-warning-time 60) ;; start warning 60 minutes before appointments
  (setq appt-display-interval 10) ;; display warning every minute
  (appt-activate t) ;; starts the appt "mode"
  (org-agenda-to-appt t)
  (require 'notifications)


  (setq appt-disp-window-function
        (lambda (remaining new-time msg)
          (notifications-notify
           :title (message "In %s minutes" remaining)
           :body msg
           :urgency 'critical)))
  (advice-add 'appt-check
              :before
              (lambda (&rest args)
                (org-agenda-to-appt t)))

#+end_src

#+RESULTS:

** IN-PROGRESS =capture=
=org-capture= nos permite tomar notas rapidamente. 
#+begin_src emacs-lisp :tangle init.el 
    (setq org-capture-templates
          '(("n" "Notes" entry (file+headline "/home/nicolas/Documents/org/notes.org" "Unsorted")
             "* UNSEEN %?\n")
            ("g" "Goals" entry (file+headline "/home/nicolas/Documents/org/goals.org" "Unsorted")
             "* TODO %?\n")
            ("i" "Inbox" entry (file+headline "/home/nicolas/Documents/org/notes.org" "Inbox")
             "* TODO <%<%Y-%m-%d %H:%M:%S>> \n %?\n")
  	  ("t" "Tasks" entry (file+headline "/home/nicolas/Documents/org/tasks.org" "Tarefas")
             "* TODO %?\n")))
#+end_src

#+RESULTS:
| n | Notes | entry | (file+headline /home/nicolas/.config/emacs/private/org/notes.org Unsorted) | * UNSEEN %?                   |
| g | Goals | entry | (file+headline /home/nicolas/.config/emacs/private/org/goals.org Unsorted) | * TODO %?                     |
| i | Inbox | entry | (file+headline /home/nicolas/.config/emacs/private/org/notes.org Inbox)    | * TODO <%<%Y-%m-%d %H:%M:%S>> |

** =org-modern=
Deixa o =org-mode= com uma aparência mais moderna.
#+begin_src emacs-lisp :tangle init.el
  (use-package org-modern
    :straight (:host github :repo "minad/org-modern" :branch "main")
    :config (setq org-modern-table nil)
    :config (setq org-modern-label-border nil)
    :hook (org-mode . org-modern-mode))	
#+end_src

#+RESULTS:
| #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | delve--maybe-activate-minor-mode | org-cdlatex-mode | org-modern-mode | org-ref-org-menu | (lambda nil (require 'org-ref)) | jupyter-org-interaction-mode | org-transclusion-mode | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-fold-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | auto-fill-mode | org-indent-mode | my/sane-heading-size | org-babel-jupyter-make-local-aliases |

** =svg-tags=
Altera org-tags para svgs customizados dos mesmos.
#+begin_src emacs-lisp :tangle init.el
  (use-package svg-lib)
  (use-package svg-tag
    :ensure svg-lib
    :straight (:host github :repo "rougier/svg-tag-mode" :branch "main")
    :hook (org-mode . svg-tag-mode))
  (setq svg-tag-tags
        '(("\\(:@[A-Za-z0-9]+\\)" . ((lambda (tag)
                                       (svg-tag-make (upcase tag) :beg 2))))
           ("\\(:@[A-Za-z0-9]+:\\)$" . ((lambda (tag)
                                         (svg-tag-make (upcase tag) :beg 2 :end -1))))
          ("\\(:@[A-Za-z]+:\\)" . ((lambda (tag) (svg-tag-make (upcase tag) :beg 2 :end -1))))
          ("\\(#.transclude: .*\\)" . ((lambda (tag) (svg-tag-make tag :beg 57 :end -2))
                                       (lambda () (interactive) (org-transclusion-add))))
          ("\\[#[A-Z]\\]" . ( (lambda (tag)
                              (svg-tag-make tag :face 'org-priority 
                                            :beg 2 :end -1 :margin 0))))
          ("TODO" . ((lambda (tag) (svg-tag-make "TODO" :face 'org-todo :inverse t :margin 0))))
          ("NEXT" . ((lambda (tag) (svg-tag-make "NEXT" :face 'org-todo :inverse t :margin 0))))
          ("BACKLOG" . ((lambda (tag) (svg-tag-make "BACKLOG" :face 'org-todo :inverse t :margin 0))))
          ("REVIEW" . ((lambda (tag) (svg-tag-make "REVIEW" :face 'org-todo :inverse t :margin 0))))
          ("IN-PROGRESS" . ((lambda (tag) (svg-tag-make "IN-PROGRESS" :face 'org-todo :inverse t :margin 0))))
          ("WAITING" . ((lambda (tag) (svg-tag-make "WAITING" :face 'org-todo :inverse t :margin 0))))
          ("DONE" . ((lambda (tag) (svg-tag-make "DONE" :face 'org-done :margin 0))))
          ("ABANDONED" . ((lambda (tag) (svg-tag-make "ABANDONED" :face 'org-done :margin 0))))
          ("COMPLETE" . ((lambda (tag) (svg-tag-make "COMPLETE" :face 'org-done :margin 0))))
          ))

#+end_src

#+RESULTS:
| \(:@[A-Za-z0-9]+\)   | (lambda (tag) (svg-tag-make (upcase tag) :beg 2))                              |                                                   |
| \(:@[A-Za-z0-9]+:\)$ | (lambda (tag) (svg-tag-make (upcase tag) :beg 2 :end -1))                      |                                                   |
| \(:@[A-Za-z]+:\)     | (lambda (tag) (svg-tag-make (upcase tag) :beg 2 :end -1))                      |                                                   |
| \(#.transclude: .*\) | (lambda (tag) (svg-tag-make tag :beg 57 :end -2))                              | (lambda nil (interactive) (org-transclusion-add)) |
| \[#[A-Z]\]           | (lambda (tag) (svg-tag-make tag :face 'org-priority :beg 2 :end -1 :margin 0)) |                                                   |
| TODO                 | (lambda (tag) (svg-tag-make TODO :face 'org-todo :inverse t :margin 0))        |                                                   |
| NEXT                 | (lambda (tag) (svg-tag-make NEXT :face 'org-todo :inverse t :margin 0))        |                                                   |
| BACKLOG              | (lambda (tag) (svg-tag-make BACKLOG :face 'org-todo :inverse t :margin 0))     |                                                   |
| REVIEW               | (lambda (tag) (svg-tag-make REVIEW :face 'org-todo :inverse t :margin 0))      |                                                   |
| IN-PROGRESS          | (lambda (tag) (svg-tag-make IN-PROGRESS :face 'org-todo :inverse t :margin 0)) |                                                   |
| WAITING              | (lambda (tag) (svg-tag-make WAITING :face 'org-todo :inverse t :margin 0))     |                                                   |
| DONE                 | (lambda (tag) (svg-tag-make DONE :face 'org-done :margin 0))                   |                                                   |
| ABANDONED            | (lambda (tag) (svg-tag-make ABANDONED :face 'org-done :margin 0))              |                                                   |
| COMPLETE             | (lambda (tag) (svg-tag-make COMPLETE :face 'org-done :margin 0))               |                                                   |

** =org-cdlatex=
A biblioteca =org-cdlatex= adiciona algumas opções para agilizar a
escrita matemática em documentos =org=.

#+begin_src emacs-lisp :tangle init.el
    (use-package cdlatex
      :hook (org-mode . org-cdlatex-mode)

      ;; comandos extras
      :config (add-to-list 'cdlatex-math-modify-alist '(115 "\\mathscr" nil t nil nil))
              (add-to-list 'cdlatex-math-modify-alist '(66 "\\mathbb" nil t nil nil))
              (add-to-list 'cdlatex-math-modify-alist '(107 "\\mathfrak" nil t nil nil))
              (add-to-list 'cdlatex-math-symbol-alist '(42 ("\\times" "\\otimes")))
              (add-to-list 'cdlatex-math-symbol-alist '(100 ("\\delta" "\\partial" "^{\\dag}")))
              (add-to-list 'cdlatex-math-symbol-alist '(46 ("\\cdot" "\\odot")))
              (add-to-list 'cdlatex-math-symbol-alist '(126 ("\\approx" "\\simeq" "\\propto")))
              (cdlatex-reset-mode))
#+end_src

* aparência
Aqui vou definir as coisas importantes para a aparência. 

** COMMENT NANO emacs
Versão bonitinha do emacs. Vou testar.

#+begin_src emacs-lisp :tangle init.el
  (straight-use-package
   '(nano :type git :host github :repo "rougier/nano-emacs"))
  (setq nano-font-family-monospaced "Ligamonacop")
  (setq nano-font-size 12)
  (require 'nano)
#+end_src

** fonte

#+begin_src emacs-lisp :tangle init.el 
  (setq default-font "Ligamonacop 12")
  (set-frame-font default-font nil t)
  (setq default-frame-alist '((font . "Ligamonacop 12")))
#+end_src

#+RESULTS:
: ((font . Ligamonacop 14))
** prettify lambda
Para escrever \lambda ao invés de lambda no =elisp=, mas sem perder o texto correto.
#+begin_src emacs-lisp :tangle init.el
  ;; (defun my-pretty-lambda ()
  ;;   "make some word or string show as pretty Unicode symbols"
  ;;   (setq prettify-symbols-alist '(
  ;;           ("lambda" . 955))))
  ;; (add-hook 'emacs-lisp-hook 'my-pretty-lambda)
  ;; (global-prettify-symbols-mode 1)
#+end_src

#+RESULTS:
: t

** =all-the-icons=
=all-the-icons= é um pacote que adiciona ícones nas coisas do =emacs=.
#+begin_src emacs-lisp :tangle init.el 
  (use-package all-the-icons
    :straight (:host github :repo "domtronn/all-the-icons.el" :branch "master"))

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src
** tema

Instalando alguns temas pra poder escolher.

#+begin_src emacs-lisp :tangle init.el 
    (use-package base16-theme)
    (use-package doom-themes)
    (use-package modus-themes
      :straight (:host gitlab :repo "protesilaos/modus-themes" :branch "main"))
    (defvar my/theme 'base16-catppuccin-latte) ;;anterior: 'doom-tokyo-night
    (load-theme my/theme t nil)
#+end_src

#+RESULTS:
: t

** outras coisas menores
#+begin_src emacs-lisp :tangle init.el
  (global-hl-line-mode t)
  (setq font-latex-fontify-script nil)
  (scroll-bar-mode -1)
  (whitespace-mode)
  (set-fringe-mode 10)
  (setq visual-bell t)
  (show-paren-mode t)
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (setq ispell-dictionary "pt_BR")
  (put 'narrow-to-region 'disabled nil) ;; tira o aviso de narrow-to-region
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  ;; (add-hook 'text-mode-hook 'display-line-numbers-mode)
#+end_src

#+RESULTS:
| rainbow-delimiters-mode | company-mode | copilot-mode | hs-minor-mode | display-line-numbers-mode |

** ligature

#+begin_src emacs-lisp :tangle init.el
(use-package ligature
  :config
  ;; Enable the "www" ligature in every possible major mode
  (ligature-set-ligatures 't '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  ;; Enable all Cascadia Code ligatures in programming modes
  (ligature-set-ligatures 'org-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "__" "~~" "(*" "*)"))
  (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "__" "~~" "(*" "*)"))
  ;; Enables ligature checks globally in all buffers. You can also do it
  ;; per mode with `ligature-mode'.
  (global-ligature-mode t))
#+end_src

#+RESULTS:

** =doom-modeline=
#+begin_src emacs-lisp :tangle init.el
    (use-package doom-modeline
      :straight (:host github :repo "seagle0128/doom-modeline" :branch "master")
      :config (setq doom-modeline-buffer-file-name-style 'buffer-name)
  	     (setq doom-modeline-buffer-encoding nil)
      :config (add-hook 'after-make-frame-functions (lambda (frame)
                                                      (setq doom-modeline-icon t))))
    (doom-modeline-mode)
#+end_src

#+RESULTS:
: t

* QoL
Pacotes e configurações que utilizo no dia-a-dia de qualidade de
vida. Inclue travas, algumas opções menos relevantes.
** auto-save-disable
Auto-save do =emacs= adiciona um bocado de lixo no diretório, que
geralmente não faz diferença.
#+begin_src emacs-lisp :tangle init.el 
 (setq make-backup-files nil)
 (setq auto-save-default nil)
#+end_src
** duplicate line
Duplica a linha abaixo. Simples e eficaz.
#+begin_src emacs-lisp :tangle init.el
  (keymap-global-set "C-," 'duplicate-line)
#+end_src
** scratch buffer
Mexendo um pouco no buffer =*scratch*=. Quero mantê-lo sempre aberto.
#+begin_src emacs-lisp :tangle init.el 
 (with-current-buffer (get-buffer-create "*scratch*"))
   (lisp-interaction-mode)
   (make-local-variable 'kill-buffer-query-functions)
   (add-hook 'kill-buffer-query-functions 'kill-scratch-buffer)

 (defun kill-scratch-buffer ()
   ;; The next line is just in case someone calls this manually
   (set-buffer (get-buffer-create "*scratch*"))
   ;; Kill the current (*scratch*) buffer
   (remove-hook 'kill-buffer-query-functions 'kill-scratch-buffer)
   (kill-buffer (current-buffer))
   ;; Make a brand new *scratch* buffer
   (set-buffer (get-buffer-create "*scratch*"))
   (insert initial-scratch-message)  
   (lisp-interaction-mode)
   (make-local-variable 'kill-buffer-query-functions)
   (add-hook 'kill-buffer-query-functions 'kill-scratch-buffer)
   ;; Since we killed it, don't let caller do that.
   nil)
#+end_src 
** =yes-or-no= to =y-or-n=
#+begin_src emacs-lisp :tangle init.el 
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
** camelCase como duas palavras
#+begin_src emacs-lisp :tangle init.el 
(global-subword-mode 1)
#+end_src
** seguir o split da janela
Quando separamos uma janela, ele segue a janela automaticamente. Muito útil.
#+begin_src emacs-lisp :tangle init.el 
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+end_src  
** =revert-buffer=
Keybind para refrescar a janela.
#+begin_src emacs-lisp :tangle init.el 
(global-set-key (kbd "<f5>") 'revert-buffer)
#+end_src
** definir =auto-fill=
#+begin_src emacs-lisp :tangle init.el 
  (setq fill-column 72)
#+end_src
** Uso de hyper
Com o teclado que tenho utilizado, a tecla hyper se tornou muito mais
prática de ser pressionada. Portanto, posso adicionar algumas coisas
nela.
#+begin_src emacs-lisp :tangle init.el
   (keymap-global-set "C-M-s-<iso-lefttab>" 'other-window)
#+end_src

#+RESULTS:
: other-window

** =abbrev-mode=
O =abbrev= funciona como o =yasnippet=, mas para pequenos termos:
serve para corrigir typos, abreviar expressões com siglas, entre
outros. Poderia ter usado bem no doutorado, mas nunca parei para configurar.
#+begin_src emacs-lisp :tangle init.el
(setq-default abbrev-mode t)
#+end_src

** =drag-stuff=
Me permite arrastar regiões, palavras e linhas por aí.
#+begin_src emacs-lisp :tangle init.el 
  (use-package drag-stuff
    :config (drag-stuff-global-mode t)
    :bind (("<M-up>" . drag-stuff-up)
	   ("<M-down>" . drag-stuff-down)
	   ("<M-left>" . drag-stuff-left)
	   ("<M-right>" . drag-stuff-right))
  )
#+end_src
** =expand-region=
=expand-region= vai selecionando o texto por unidades semânticas:
palava, frase, parágrafo, etc.
#+begin_src emacs-lisp :tangle init.el 
  (use-package expand-region
    :bind ("C-=" . er/expand-region)
    )
#+end_src

** =hide-show-mode=
Permite ocultar blocos dentro de códigos. Acessível pelos comandos
diretos do =vim=: =zr= (show-all), =zm= (fold-all), =zo= (show-this) e
=zc= (fold-this).
#+begin_src emacs-lisp :tangle init.el
  (add-hook 'prog-mode-hook 'hs-minor-mode)
#+end_src

#+RESULTS:
| hs-minor-mode | rainbow-delimiters-mode | copilot-mode | display-line-numbers-mode |

** =Ibuffer=
=Ibuffer= é uma interface customizável para a edição de buffers.
#+begin_src emacs-lisp :tangle init.el 
  (use-package ibuffer
    :bind  ("C-x C-b" . ibuffer)
    :config (setq ibuffer-saved-filter-groups
          (quote (("default"
                   ("dired" (mode . dired-mode))
                   ("org" (mode . org-mode))
  		 
                   ("programming" (or
                                   (mode . sh-mode)
                                   (mode . c-mode)
                                   (mode . python-mode)
                                   (mode . c++-mode)))
                   ("latex" (mode . latex-mode))
                   ("document" (mode . pdf-view-mode))
                   ("image" (mode . image-mode)) 
                   ("magit" (name . "^\\Magit.*"))
                   ("IRC" (mode . erc-mode))
                   ("notmuch" (or
                               (name . "^.*otmuch.*$")
                               (mode . notmuch-hello-mode)
                               (mode . notmuch-search-mode)
                               (mode . notmuch-show-mode)
                               (mode . notmuch-tree-mode)
                               (mode . notmuch-message-mode)))
                   ("ledger" (or (mode . ledger-mode) (mode . ledger-report-mode)))
                   ("emms" (name . "^\\*EMMS.*"))
                   ("emacs" (or
                             (name . "^\\*scratch\\*$")
                             (name . "^\\*Messages\\*$")))
                   ))))
    :config (add-hook 'ibuffer-mode-hook
              (lambda ()
                (ibuffer-auto-mode 1)
                (ibuffer-switch-to-saved-filter-groups "default")))
    :config (setq ibuffer-show-empty-filter-groups nil)
    :config (setq ibuffer-expert t)
    :hook (ibuffer-mode . (lambda ()
      (ibuffer-projectile-set-filter-groups)
      (unless (eq ibuffer-sorting-mode 'alphabetic)
        (ibuffer-do-sort-by-alphabetic)))))
#+end_src
** navegacao
Vou utilizar =vertico= e =marginalia= para movimentação pelos
documentos, organização do minibuffer. Preciso ativar o =ivy-mode= para
que funcione bem o =ledger=.
*** =ace-window=
Se o =avy= faz milagre /inbuffer/, o =ace= faz entre /windows/.
#+begin_src emacs-lisp :tangle init.el 
  (use-package ace-window
    :bind ("C-x o" . ace-window)
    :bind ("M-p" . other-window))
#+end_src
*** =avy= e =ivy=
Duas funções que gosto bastante: =avy= permite pular para o
caractere/linha com combinações de caracteres, e =ivy= é importante pro
=ledger=.
#+begin_src emacs-lisp :tangle init.el 
  (use-package avy
    :config (setq avy-keys '(?a ?r ?s ?t ?n ?e ?i ?o))
    :bind (("M-s M-s" . avy-goto-char)
           ("M-g M-g" . avy-goto-line)))  
#+end_src

#+RESULTS:
: avy-goto-line

#+begin_src emacs-lisp :tangle init.el
  (use-package ivy
    :init (progn (ivy-mode 1)
                 (ivy-mode -1)))
#+end_src

#+RESULTS:

*** =consult=
=consult= estende alguns comandos padrões do =emacs=.
#+begin_src emacs-lisp :tangle init.el
  ;; Example configuration for Consult
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings in `mode-specific-map'
           ("C-c M-x" . consult-mode-command)
           ;; ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ;; ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ([remap Info-search] . consult-info)
           ;; C-x bindings in `ctl-x-map'
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings in `goto-map'
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-make)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ;; ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-find)
           ("M-s D" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key "M-.")
    ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; "C-+"

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; By default `consult-project-function' uses `project-root' from project.el.
    ;; Optionally configure a different project root function.
    ;;;; 1. project.el (the default)
    ;; (setq consult-project-function #'consult--default-project--function)
    ;;;; 2. vc.el (vc-root-dir)
    ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
    ;;;; 3. locate-dominating-file
    ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
    ;;;; 4. projectile.el (projectile-project-root)
    ;; (autoload 'projectile-project-root "projectile")
    ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
    ;;;; 5. No project support
    ;; (setq consult-project-function nil)
    )
#+end_src

*** =eldoc-box=
Mostra um popup do eldoc ao invés de buffer dedicado.
#+begin_src emacs-lisp :tangle init.el
(use-package eldoc-box)
#+end_src

#+RESULTS:

*** =embark=

=embark= adiciona um dwim helper no =C-.=
#+begin_src emacs-lisp :tangle init.el
  (use-package embark
    :demand t				;
    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

    :init

    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    ;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
    ;; strategy, if you want to see the documentation from multiple providers.
    (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
    ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

    :config

    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :ensure t ; only need to install it, embark loads it after consult if found
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

#+RESULTS:
| embark-consult--upgrade-markers | consult-preview-at-point-mode |

*** =marginalia=
=marginalia= adiciona informação no minibuffer.
#+begin_src emacs-lisp :tangle init.el
  (use-package marginalia
      :init (marginalia-mode))
#+end_src

*** =orderless=
=orderless= adiciona completion fuzzy.
#+begin_src emacs-lisp :tangle init.el
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic flex))
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

*** =vertico=
=vertico= é o novo =helm=, =ido=, =ivy= etc. Está sendo bastante útil.
#+begin_src emacs-lisp :tangle init.el
  (use-package vertico
    :init (vertico-mode)
    :init (vertico-multiform-mode)
    :straight (:files (:defaults "extensions/*"))
    :bind ( :map vertico-map
            ("RET" . vertico-directory-enter)
            ("DEL" . vertico-directory-delete-char)
            ("M-DEL" . vertico-directory-delete-word))
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)
    :config (setq read-file-name-completion-ignore-case t
                  read-buffer-completion-ignore-case t
                  completion-ignore-case t))
#+end_src


** =transpose-frame=
Rotaciona as janelas do frame, útil se ele particionou errado.
#+begin_src emacs-lisp :tangle init.el
(use-package transpose-frame)
#+end_src

#+RESULTS:

** =pass=
O Ubuntu não se dá bem com pass, e estou cansado de autocomplete no
terminal. Vou usar direto no =emacs= mesmo, pelo menos lá dá menos problema.
#+begin_src emacs-lisp :tangle init.el
  (use-package pass)
  (use-package ivy-pass
    :bind ("s-R" . ivy-pass))
#+end_src

#+RESULTS:
: ivy-pass

** =undo-tree=
=undo-tree= é uma árvore de =undo/redo=, parecendo branches de git.
#+begin_src emacs-lisp :tangle init.el 
  (use-package undo-tree
    :config (global-undo-tree-mode 1))
#+end_src

** =vterm=
O melhor terminal dentro do =emacs=, de disparada.
#+begin_src emacs-lisp :tangle init.el 
    (use-package vterm
      :after multi-vterm
      :init (setq vterm-shell "zsh")

      ;; deixar o vterm na parte de baixo da tela
      :config (add-to-list 'display-buffer-alist
                           '("\*vterm\*"
                             (display-buffer-in-side-window)
                             (window-height . 0.25)
                             (side . bottom)
                             (slot . 0))))
      ;; (use-package vterm-toggle
      ;;   :bind ("s-t" . vterm-toggle))
    (use-package toggle-term
      :bind (("C-`" . toggle-term-toggle)
             ("C-~" . toggle-term-find)
             ;;("M-o t" . toggle-term-term)
             ("M-o v" . toggle-term-vterm)
             ;; ("M-o a" . toggle-term-eat)
             ;; ("M-o s" . toggle-term-shell)
             ;; ("M-o e" . toggle-term-eshell)
             ;; ("M-o i" . toggle-term-ielm)
             ;; ("M-o o" . toggle-term-toggle)
             )
      :config
      (setq toggle-term-init-toggle '("my-terminal" . "vterm"))
      (setq toggle-term-size 25)
      (setq toggle-term-switch-upon-toggle t))

  #+end_src

#+RESULTS:
: toggle-term-vterm

Tem até como usar como multiplexer com o =multi-vterm=.
#+begin_src emacs-lisp :tangle init.el
  ;; (use-package multi-vterm)
#+end_src

#+RESULTS:
: t

** =winner-mode=
Ele salva modificações de janela pra poder fazer e desfazer as coisas.
#+begin_src emacs-lisp :tangle init.el
  (winner-mode)
#+end_src
** which-key
Descreve os possíveis comandos a partir de um /key-chord/ parcial.
#+begin_src emacs-lisp :tangle init.el 
  (use-package which-key
    :init (which-key-mode))
#+end_src
** =tree-sitter=
Sistema de parse para linguagens de programação mais recente que regex-based. 
#+begin_src emacs-lisp :tangle init.el
  (use-package tree-sitter)
#+end_src

** =centaur-tabs=
Adiciona abas no =emacs=. Eu tenho o costume de usar, mas não sei se faz
toda essa diferença.
#+begin_src emacs-lisp :tangle no
  (use-package centaur-tabs
    :demand
    :config
    (centaur-tabs-mode t)
    (setq centaur-tabs-style "bar")
    (setq centaur-tabs-set-icons t)
    (setq centaur-tabs-gray-out-icons 'buffer)
    (setq centaur-tabs-set-bar 'over)
    (setq centaur-tabs-set-modified-marker t)
    (setq centaur-tabs-cycle-scope 'tabs)
    (setq centaur-tabs-label-fixed-length 8)
    :bind
    ("C-<tab>" . centaur-tabs-forward)
    ("C-<iso-lefttab>" . centaur-tabs-backward)
    :hook (vterm-mode . centaur-tabs-local-mode)
    (ein:notebook-mode . centaur-tabs-local-mode)
    (ein:notebooklist-mode . centaur-tabs-local-mode))
#+end_src

#+RESULTS:
: centaur-tabs-backward

** zoom-window
Modo zoom - similar ao =<leader> z= do tmux.
#+begin_src emacs-lisp :tangle init.el
  (defvar zoom-register ?z
     "the register to store the window configuration for zooming/unzooming.")

   (defvar zoomed-in-p nil
     "a flag to track if the window is currently zoomed in.")

   (defun toggle-zoom-window ()
     "toggle zooming the current window: maximize or restore."
     (interactive)
     (if zoomed-in-p
         (restore-window-configuration-from-zoom-register)
       (save-window-configuration-to-zoom-register)
       (delete-other-windows))
     (setq zoomed-in-p (not zoomed-in-p)))

   (defun save-window-configuration-to-zoom-register ()
     "save the current window configuration to a register for zooming/unzooming."
     (window-configuration-to-register zoom-register)
     (message "Window configuration saved for zooming."))

   (defun restore-window-configuration-from-zoom-register ()
     "restore the window configuration from the zoom register."
     (jump-to-register zoom-register)
     (message "Window configuration restored."))

  (global-set-key (kbd "M-z") 'toggle-zoom-window)
#+end_src

#+RESULTS:
: toggle-zoom-window


* features
** COMMENT =dashboard=
Cria um dashboard das informações recentes relevantes.
#+begin_src emacs-lisp :tangle init.el 
  (use-package dashboard
    :init (setq dashboard-startup-banner "~/.config/emacs/private/img/ihs2.png") 
    ;; :init (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
    :init (dashboard-setup-startup-hook)
    :init (add-to-list 'recentf-exclude (recentf-expand-file-name "~/.config/emacs/private/*" ))
    :config (setq dashboard-banner-logo-title "Iesu Hominum Salvator"
                  dashboard-items '(
                                    ;; (recents  . 5)
                                    (bookmarks . 5)
                                    (projects . 5)
                                    (agenda . 5)
                                          ;(registers . 5)
                                    )
                   dashboard-footer-messages 'nil ;AD MAIOREM DEI GLORIAM🇻🇦")
                   dashboard-footer-icon "🇻🇦"
                   dashboard-set-heading-icons t
                   dashboard-set-file-icons t
                   ;; (setq dashboard-set-init-info nil)
                   dashboard-center-content t))
#+end_src

#+RESULTS:
: t
** COMMENT =copilot=
Podemos configurar o uso do copilot, do github, aqui no emacs. Para
isso, preciso do login do github da BlackGenn.
#+begin_src emacs-lisp :tangle init.el
    (use-package copilot
      :straight (:host github :repo "copilot-emacs/copilot.el" :files ("*.el"))
      :hook (prog-mode . copilot-mode)
      :bind (:map copilot-completion-map ("<tab>" . copilot-accept-completion)
                                   ("TAB" . copilot-accept-completion))
      :init (copilot-install-server)
      :ensure t)
    (use-package shell-maker
      :straight (:host github :repo "xenodium/shell-maker" :files ("*.el")))
    (use-package copilot-chat
      :straight (:host github :repo "chep/copilot-chat.el" :files ("*.el"))
      :after (request org markdown-mode)
      :ensure shell-maker)
#+end_src

#+RESULTS:

** =corfu=
Autocompletion.
#+begin_src emacs-lisp :tangle init.el
  (use-package corfu
   :init (global-corfu-mode))
#+end_src

** =company=
#+begin_src emacs-lisp :tangle init.el
  (use-package company
    :config (setq company-idle-delay 0
                  company-minimum-prefix-length 1
                  company-tooltip-align-annotations t)
    :hook (prog-mode . company-mode))
#+end_src

#+RESULTS:
| global-company-mode | x-wm-set-size-hint | org-roam-db-autosync-mode | org-persist-load-all | debian-ispell-set-default-dictionary | debian-ispell-set-startup-menu | tramp-register-archive-autoload-file-name-handler | table--make-cell-map | magit-maybe-define-global-key-bindings |

** =dired=
Um pouco de customização e extensão do =dired= não faz mal nenhum.
#+begin_src emacs-lisp :tangle init.el 
  (use-package dired-plus
    :straight (:host github :repo "emacsmirror/dired-plus"
                     :branch "master")
    :bind ("C-x C-j" . dired-jump)
    :config (setq dired-kill-when-opening-new-dired-buffer t)
    :init (setq dired-listing-switches "-glh --group-directories-first")
    (setq dired-dwim-target t))
#+end_src
=dired-preview= é capaz de gerar /preview/ de arquivos compatíveis - texto,
imagem.
#+begin_src emacs-lisp :tangle init.el 
  (use-package dired-preview
    :init (dired-preview-global-mode 0)
    :config (setq dired-preview-delay 0.7)
    (setq dired-preview-ignored-extensions-regexp
  	(concat "\\."
              "\\(mkv\\|webm\\|mp4\\|mp3\\|ogg\\|m4a"
              "\\|gz\\|zst\\|tar\\|xz\\|rar\\|zip"
              "\\|iso\\|epub\\)")))
#+end_src

** =projectile=
=projectile= é um pacote que unifica os projetos e permite toda uma
coerência entre os arquivos do mesmo.
#+begin_src emacs-lisp :tangle init.el 
  (use-package projectile
    :config
    (projectile-global-mode 1) 
    (setq projectile-completion-system 'ivy)
    :bind-keymap 
    ("C-c p" . projectile-command-map))

  (use-package ibuffer-projectile) ;; agrupa buffers do mesmo projeto
#+end_src
** custom: =harpoon=
Copiando o harpoon do neovim.
#+begin_src emacs-lisp :tangle init.el
  (load-file "~/.config/emacs/custom/harpoon.el")
  (global-set-key (kbd "C-M-s-SPC") 'harpoon-add-buffer-to-register)
  (global-set-key (kbd "C-M-s-<return>") 'harpoon-show-menu)
  (global-set-key (kbd "C-M-s-<escape>") 'harpoon-remove-buffer-from-register)
#+end_src

#+begin_src emacs-lisp :tangle custom/harpoon.el
      (defvar harpoon-registers '(?p ?f ?w ?q ?g ?l ?u ?y ?j))
      (defvar harpoon-register-alist nil
        "Alist mapping register characters to buffer/file paths.")

      (defun harpoon-add-buffer-to-register ()
        "Add current buffer/file to first available harpoon register.
          If all registers are used, prompt user to remove one."
        (interactive)
        (let* ((buffer-file (or (buffer-file-name) (buffer-name)))
               (existing-reg (car (rassoc buffer-file harpoon-register-alist)))
               (available-reg (cl-set-difference harpoon-registers
                                                 (mapcar #'car harpoon-register-alist))))
          (cond
           (existing-reg
            (message "Buffer/file already in register %c" existing-reg))
           (available-reg
            (let ((reg (car available-reg)))
              (push (cons reg buffer-file) harpoon-register-alist)
              (message "Added to register %c" reg)))
           (t
            (when (y-or-n-p "All registers used. Remove one? ")
              (let* ((choices (mapcar (lambda (x)
                                        (format "%c: %s" (car x) (cdr x)))
                                      harpoon-register-alist))
                     (selected (completing-read "Remove register: " choices nil t))
                     (reg-char (string-to-char selected)))
                (setq harpoon-register-alist
                      (assq-delete-all reg-char harpoon-register-alist))
                (push (cons reg-char buffer-file) harpoon-register-alist)
                (message "Replaced register %c" reg-char)))))))

      (defun harpoon-remove-buffer-from-register ()
        "Remove current buffer/file from its harpoon register."
        (interactive)
        (let* ((buffer-file (or (buffer-file-name) (buffer-name)))
               (existing-reg (car (rassoc buffer-file harpoon-register-alist))))
          (if existing-reg
              (progn
                (setq harpoon-register-alist
                      (assq-delete-all existing-reg harpoon-register-alist))
                (message "Removed from register %c" existing-reg))
            (message "Buffer/file not in any register"))))

      (defun harpoon-show-menu ()
        "Show an interactive menu of harpoon registers."
        (interactive)
        (let ((choices (mapcar (lambda (r)
                                 (cons (format "%c: %s" r (or (cdr (assq r harpoon-register-alist)) "[empty]")) r))
                               harpoon-registers)))
          (let ((selection (completing-read "Jump to register: " choices nil t)))
            (when selection
              (let ((reg (cdr (assoc selection choices))))
                (call-interactively (intern (format "harpoon-jump-%c" reg))))))))
#+end_src

#+begin_src emacs-lisp :tangle custom/harpoon.el
(defun harpoon-show-list-and-jump ()
  "Show harpoon registers and jump to selected one."
  (interactive)
  (let ((buffer (get-buffer-create "*Harpoon Registers*")))
    ;; Display the list in a help buffer
    (with-help-window buffer
      (with-current-buffer buffer
        (insert "Harpoon Registers - press key to jump:\n\n")
        (dolist (reg harpoon-registers)
          (let ((target (cdr (assq reg harpoon-register-alist))))
            (insert (format "%c: %s\n" reg 
                          (if target
                              (abbreviate-file-name
                               (if (stringp target) target (buffer-name target)))
                            "[empty]")))))))
    
    ;; Prompt for register key
    (let ((reg (read-char "Jump to register: ")))
      (when (memq reg harpoon-registers)
        (let ((target (cdr (assq reg harpoon-register-alist))))
          (cond
           ((not target)
            (message "Register %c is empty" reg))
           ((file-exists-p target)
            (find-file target))
           ((get-buffer target)
            (switch-to-buffer target))
           (t
            (message "Target no longer exists")))))
      (when (get-buffer "*Harpoon Registers*")
        (kill-buffer "*Harpoon Registers*")))))
#+end_src

#+RESULTS:
: harpoon-show-menu

#+begin_src emacs-lisp :tangle custom/harpoon.el
(defun harpoon-create-jump-functions ()
  "Create direct jump functions for all harpoon registers."
  (dolist (reg harpoon-registers)
    (fset (intern (format "harpoon-jump-%c" reg))
          `(lambda ()
             (interactive)
             (let ((buffer-file (cdr (assq ',reg harpoon-register-alist))))
               (cond
                ((not buffer-file)
                 (message "Register %c is empty" ',reg))
                ((file-exists-p buffer-file)
                 (find-file buffer-file))
                ((get-buffer buffer-file)
                 (switch-to-buffer buffer-file))
                (t
                 (message "Buffer/file %s no longer exists" buffer-file)))))))

  ;; Create keybindings
  (dolist (reg harpoon-registers)
    (define-key global-map (kbd (format "C-M-S-s-%c" reg))
              (intern (format "harpoon-jump-%c" reg)))))

  (harpoon-create-jump-functions)
#+end_src

#+RESULTS:

#+begin_src emacs-lisp :tangle no
(require 'projectile)  ; Or use your preferred project management system

(defun harpoon-get-project-r5ot ()
  "Get current project root directory."
  (when (fboundp 'projectile-project-root)
    (projectile-project-root)))

(defun harpoon-get-storage-file ()
  "Get path to harpoon storage file for current project."
  (let ((root (harpoon-get-project-root)))
    (when root
      (expand-file-name ".harpoon" root))))

(defun harpoon-save-registers ()
  "Save harpoon registers to project-specific file."
  (interactive)
  (let ((file (harpoon-get-storage-file)))
    (when file
      (make-directory (file-name-directory file) t)
      (with-temp-file file
        (prin1 harpoon-register-alist (current-buffer))))))

(defun harpoon-load-registers ()
  "Load harpoon registers from project-specific file."
  (interactive)
  (let ((file (harpoon-get-storage-file)))
    (when (and file (file-exists-p file))
      (with-temp-buffer
        (insert-file-contents file)
        (setq harpoon-register-alist (read (current-buffer)))))))

;; Automatically load/save when changing buffers
(add-hook 'find-file-hook 'harpoon-load-registers)
(add-hook 'kill-buffer-hook 'harpoon-save-registers)
#+end_src

#+begin_src emacs-lisp :tangle no
(defun harpoon-switch-project ()
  "Switch projects and load corresponding harpoon registers."
  (interactive)
  (call-interactively 'projectile-switch-project)
  (harpoon-load-registers))

(define-key projectile-mode-map (kbd "C-c p h") 'harpoon-switch-project)
#+end_src

#+begin_src emacs-lisp :tangle no
(defun harpoon-get-global-storage-file ()
  "Get path to global harpoon storage file."
  (expand-file-name "~/.config/emacs/custom/harpoon-global"))

(defun harpoon-save-global-registers ()
  "Save registers to global storage."
  (interactive)
  (let ((file (harpoon-get-global-storage-file)))
    (with-temp-file file
      (prin1 harpoon-register-alist (current-buffer)))))

(defun harpoon-load-global-registers ()
  "Load registers from global storage."
  (interactive)
  (let ((file (harpoon-get-global-storage-file)))
    (when (file-exists-p file)
      (with-temp-buffer
        (insert-file-contents file)
        (setq harpoon-register-alist (read (current-buffer)))))))

;; Add to emacs startup
(add-hook 'after-init-hook 'harpoon-load-global-registers)
#+end_src

#+begin_src emacs-lisp :tangle no
(defun harpoon-load-registers ()
  "Load registers from project or global storage."
  (let ((project-file (harpoon-get-storage-file)))
    (cond
     ((and project-file (file-exists-p project-file))
      (with-temp-buffer
        (insert-file-contents project-file)
        (setq harpoon-register-alist (read (current-buffer)))))
     (t
      (harpoon-load-global-registers)))))

(defun harpoon-save-registers ()
  "Save registers to appropriate storage."
  (if (harpoon-get-project-root)
      (harpoon-save-registers)
    (harpoon-save-global-registers)))
#+end_src

** =magit=
Uma porcelana =git= que é realmente de outro mundo.
#+begin_src emacs-lisp :tangle init.el 
  (use-package with-editor
    :straight nil)
  (use-package magit
    :bind ("C-x g" . magit-status))
#+end_src

Adiciona um processo para utilizar o PYTHONPATH, permitindo testes e
precommit direto do magit.
#+begin_src emacs-lisp :tangle init.el 
  (add-hook 'projectile-after-switch-project-hook
            (lambda ()
              (let* ((project-root (projectile-project-root))
                     (venv-path (concat project-root ".venv")))
                (setq python-shell-extra-pythonpaths (list project-root))
                (if (file-directory-p venv-path)
                    (progn
                      (pyvenv-activate venv-path)
                      (message "Activated virtualenv: %s" venv-path))
                  (progn
                    (pyvenv-deactivate)
                    (message "No virtualenv found in project; deactivated any existing virtualenv."))))))

  (add-hook 'projectile-after-switch-project-hook
            (lambda ()
              (let ((project-root (projectile-project-root)))
                (setenv "PYTHONPATH" ":bin:src")
                (add-to-list 'process-environment (concat "PYTHONPATH=" (getenv "PYTHONPATH")))
                (message "Set PYTHONPATH to: %s" (getenv "PYTHONPATH")))))

#+end_src

#+RESULTS:
| lambda | nil | (let ((project-root (projectile-project-root))) (setenv PYTHONPATH :bin:src) (add-to-list 'process-environment (concat PYTHONPATH= (getenv PYTHONPATH))) (message Set PYTHONPATH to: %s (getenv PYTHONPATH)))                                                                                                                                                                                                      |
| lambda | nil | (let* ((project-root (projectile-project-root)) (venv-path (concat project-root .venv))) (setq python-shell-extra-pythonpaths (list project-root)) (if (file-directory-p venv-path) (progn (pyvenv-activate venv-path) (message Activated virtualenv: %s venv-path)) (progn (pyvenv-deactivate) (message No virtualenv found in project; deactivated any existing virtualenv.))))                                  |
| lambda | nil | (let ((project-root (projectile-project-root))) (setenv PYTHONPATH (expand-file-name bin project-root)) (add-to-list 'process-environment (concat PYTHONPATH= (getenv PYTHONPATH))) (message Set PYTHONPATH to: %s (getenv PYTHONPATH)))                                                                                                                                                                           |
| lambda | nil | (let* ((project-root (projectile-project-root)) (venv-path (concat project-root .venv))) (setenv PYTHONPATH project-root) (setq python-shell-extra-pythonpaths (list project-root)) (if (file-directory-p venv-path) (progn (pyvenv-activate venv-path) (message Activated virtualenv: %s venv-path)) (progn (pyvenv-deactivate) (message No virtualenv found in project; deactivated any existing virtualenv.)))) |

** =forge=
Interação com GitHub, com pull request, issues etc.
#+begin_src emacs-lisp :tangle init.el
  (use-package forge)
#+end_src

#+RESULTS:

** =treemacs=
=treemacs= é uma sidebar de árvore de arquivos.
#+begin_src emacs-lisp :tangle init.el 
  (use-package treemacs
    :bind ("C-'" . treemacs))
  (use-package treemacs-magit)
  (use-package treemacs-projectile)
  (use-package treemacs-evil)
#+end_src

#+RESULTS:

** =eglot=
=eglot= é um LSP-like do próprio emacs.
#+begin_src emacs-lisp :tangle init.el
  (use-package eglot
  :ensure t
  :defer t
  :hook
  (python-mode . eglot-ensure)
  (javascript-mode . eglot-ensure)
  (julia-mode . eglot-ensure)
  (java-mode . eglot-ensure))
#+end_src
Para acelerar o eglot, utilizamos =eglot-booster=. Precisamos
adicionar o diretório =.local/bin= no =PATH= do emacs.
#+begin_src emacs-lisp :tangle init.el
  (add-to-list 'exec-path "/home/nicolas/.local/bin")
  (use-package eglot-booster
            :after eglot
            :straight (:host github :repo "jdtsmith/eglot-booster" :branch "main")
            :config	(eglot-booster-mode))
#+end_src

#+RESULTS:
: t

Para o =eglot= funcionar corretamente, precisamos do =json-rpc=.
#+begin_src emacs-lisp :tangle init.el
  (use-package json-rpc)
#+end_src

#+RESULTS:

** =evil-mode=
Vou implementar o =evil-mode= como utilizado pelo =doom-emacs=, e
preciso configurar o mapa.
#+begin_src emacs-lisp :tangle init.el
  (use-package evil
    :init (setq evil-want-C-i-jump nil)
    (setq evil-want-C-u-scroll t)
    (evil-mode)
    :hook (delve-mode . turn-off-evil-mode))
  (evil-set-initial-state 'dired-mode 'emacs)
  (evil-set-initial-state 'vterm-mode 'emacs)
  (evil-set-initial-state 'delve-mode 'emacs)

  (use-package evil-numbers
    :bind (:map evil-normal-state-map
                ("C-c +" . evil-numbers/inc-at-pt)
                ("C-c -" . evil-numbers/dec-at-pt)))
  ;; (display-line-numbers-mode 1)
#+end_src

#+RESULTS:
: evil-numbers/dec-at-pt

Para gerar o =keymap= com leader, posso usar o =general.el=
#+begin_src emacs-lisp :tangle init.el
  (use-package general
    :config (general-evil-setup t)
    (general-create-definer my/leader-keys
      :keymaps '(normal visual)
      :prefix "SPC"))
#+end_src

#+RESULTS:

#+begin_src emacs-lisp :tangle init.el
  (my/leader-keys
    ;; file and buffer general usage
    "SPC" 'find-file 
    "RET" 'consult-bookmark
    "," 'consult-buffer
    "bb" 'ibuffer
    "bk" 'kill-buffer
    "bs" 'save-buffer
    "bl" 'next-buffer
    "bh" 'previous-buffer
    "." 'dired
    "z" 'toggle-zoom-window

    ;; commands
    "x" 'execute-extended-command
    ":" 'eval-expression
    ";" 'avy-goto-line

    ;; movement
    "TAB" 'other-window
    "s" 'avy-goto-char
    "/" 'consult-line
    "=" 'er/expand-region

    ;; ispell
    "$." 'flyspell-auto-correct-word
    "$b" 'ispell-buffer
    "$w" 'ispell-word

    ;; windows
    "w0" 'delete-window
    "w1" 'delete-other-windows
    "w2" 'split-and-follow-horizontally
    "w3" 'split-and-follow-vertically
    "wp" 'winner-undo
    "wn" 'winner-redo
    "w=" 'balance-windows
    "wt" 'transpose-frame
    "w TAB" 'ace-window

    ;; magit
    "gg" 'magit-status
    ;; "gb" 'magit-blame
    "gc" 'magit-commit
    "gC" 'magit-clone
    "gp" 'magit-push
    "gR" 'magit-revert
    "gs" 'magit-stage 
    "gx" 'magit-reset
    "gz" 'magit-stash

    ;; open general
    "om" 'notmuch
    "on" 'treemacs
    "of" 'find-file-other-window
    "o," 'consult-buffer-other-window

    ;; projectile
    "p!" 'projectile-run-shell-command-in-root
    "pf" 'projectile-find-file
    "pa" 'projectile-ag
    "p4f" 'projectile-find-file-other-window
    "pc" 'projectile-compile-project
    "pp" 'projectile-switch-project
    "p," 'projectile-switch-to-buffer
    "pk" 'projectile-kill-buffers

    ;; help
    "hf" 'describe-function
    "hk" 'describe-key
    "hv" 'describe-variable
    "hd" 'eldoc
    "h." 'eldoc-box-help-at-point

    ;; register
    "rs" 'consult-register-store
    "rl" 'consult-register-load
    "rr" 'consult-register

    ;; org roam
    "rf" 'org-roam-node-find
    "rc" 'org-roam-capture
    "rb" 'org-roam-buffer-toggle
    "rI" 'org-roam-node-insert-immediate
    "ri" 'org-roam-node-insert
    "ra" 'org-roam-alias-add
    "r]" 'org-roam-ref-find
    "rd" 'org-roam-dailies-goto-today
    "rg" 'org-roam-dailies-find-date
    "rt" 'org-transclusion-add

    ;; consult
    "cd" 'consult-find
    "cD" 'consult-locate
    "cg" 'consult-grep
    "cG" 'consult-git-grep
    "cr" 'consult-ripgrep
    "cl" 'consult-line

    ;; org ref
    "[" 'ivy-bibtex
    "]" 'org-ref-insert-link
    ")" 'org-ref-insert-ref-link

    ;; snippets
    "yi" 'yas-insert-snippet
    "yn" 'yas-new-snippet
    "yv" 'yas-visit-snippet-file

    ;; agenda
    "aa" 'org-agenda
    "a[" 'org-agenda-file-to-front
    "a]" 'org-remove-file

    ;; store link
    "ls" 'org-store-link
    "li" 'org-insert-link

    ;; multiple cursors
    "@" 'evil-multiedit-toggle-marker-here
    "m@" 'evil-multiedit-match-all
    "mn" 'evil-multiedit-match-and-next
    "mp" 'evil-multiedit-match-and-prev

    ;; narrow
    "ns" 'org-narrow-to-subtree
    "nn" 'narrow-to-region
    "np" 'narrow-to-page
    "nd" 'narrow-to-defun
    "nw" 'widen

    ;; undo-tree
    "u" 'undo-tree-visualize

    ;; elfeed
    "ee" 'elfeed

    ;; dape
    "dd" 'dape
    "di" 'dape-info
    "dk" 'dape-kill
    "dn" 'dape-next
    "dr" 'dape-restart
    "db" 'dape-breakpoint-toggle
    "dl" 'dape-breakpoint-log
    "dh" 'dape-breakpoint-hits
    "de" 'dape-breakpoint-expression
    "dB" 'dape-breakpoint-remove-all
    "dq" 'dape-quit
    "dR" 'dape-repl
    "dc" 'dape-continue
    "dw" 'dape-watch-dwim
    "dx" 'dape-evaluate-expression
    
    ;; org-babel
    "cc" 'org-ctrl-c-ctrl-c

    ;; other commands
    "ie" 'emoji-search
    "ip" 'paste-image
    "ev" 'org-babel-tangle
    "ex" 'org-export-dispatch)
 #+end_src

#+RESULTS:

=evil-collection= é uma série de integrações do =evil-mode= com otras
coisas do emacs.
#+begin_src emacs-lisp :tangle init.el
  (use-package evil-collection
    :after evil
    :ensure t
    :config
    (evil-collection-init))
#+end_src

#+RESULTS:

** =elfeed=
Não estou usando muito o =elfeed= desde muito tempo, acho que posso
deixar de usar. Tenho que atualizar o feed se quiser voltar.
#+begin_src emacs-lisp :tangle init.el
  (use-package elfeed
    :config (setq elfeed-db-directory "~/.local/share/elfeed")
    :bind ("C-c e" . elfeed))

  (use-package elfeed-org
    :straight (:host github :repo "remyhonig/elfeed-org" :branch "master"))
  (elfeed-org)
  (setq rmh-elfeed-org-files (list "~/Documents/org/elfeed.org"))
#+end_src

#+RESULTS:
| ~/.config/emacs/private/org/elfeed.org |


** COMMENT =multiple-cursors=
Múltiplos cursores!
#+begin_src emacs-lisp :tangle init.el 
  (use-package multiple-cursors
    :ensure t
    :straight nil
    :bind (("C-S-c C-S-c" . mc/edit-lines) ;; add cursor to all selected lines
           ("C->" . mc/mark-next-like-this) ;; add cursor at the next ocurrence of selection on text
           ("C-<" . mc/mark-previous-like-this) ;; add cursor at the previous ocurrence of selection on text
           ("C-S-<mouse-1>" . mc/add-cursor-on-click)
           ("C-c C-<" . mc/mark-all-like-this)) ;;  add cursor at all ocurrences of selection on buffer
    :config (setq mc/cmds-to-run-once '()))
#+end_src

** =evil-mc=
Para funcionar com o evil, temos o =evil-mc=
#+begin_src emacs-lisp :tangle init.el
  (use-package evil-mc
    :after evil
    (global-evil-mc-mode t))
#+end_src

#+RESULTS:

** =gptel=
Uso de gptel para integrar o ChatGPT na programação. Talvez até
incluí-lo em RAG.
#+begin_src emacs-lisp :tangle init.el
    (use-package gptel)
#+end_src
** =mise.el=
Para fazer o manager de binários e versionamento, podemos utilizar o
=mise-en-place=.
#+begin_src emacs-lisp :tangle init.el
    (use-package mise
      :init (mise-mode)
  	:hook (clojure-mode . mise-mode))
#+end_src

#+RESULTS:
| mise-mode | cider-mode | #[nil ((set (make-local-variable 'sesman-system) 'CIDER)) (t)] | clojure--check-wrong-major-mode |

** COMMENT =obsidian.el= 
Com esse pacote, consigo acessar arquivos do obsidian direto do emacs
com maior integração. O ByMyCell armazena toda a documentação deles em obsidian.
#+begin_src emacs-lisp :tangle init.el
(use-package obsidian
  :ensure t
  :demand t
  :config
  (obsidian-specify-path "~/Documents/BMC/Documentação")
  (global-obsidian-mode t)
  :custom
  ;; This directory will be used for `obsidian-capture' if set.
  (obsidian-inbox-directory "Inbox")
  ;; Create missing files in inbox? - when clicking on a wiki link
  ;; t: in inbox, nil: next to the file with the link
  ;; default: t
  ;(obsidian-wiki-link-create-file-in-inbox nil)
  ;; The directory for daily notes (file name is YYYY-MM-DD.md)
  (obsidian-daily-notes-directory "Daily Notes")
  ;; Directory of note templates, unset (nil) by default
  ;(obsidian-templates-directory "Templates")
  ;; Daily Note template name - requires a template directory. Default: Daily Note Template.md
  ;(obsidian-daily-note-template "Daily Note Template.md")
  :bind (:map obsidian-mode-map
  ;; Replace C-c C-o with Obsidian.el's implementation. It's ok to use another key binding.
  ("C-c C-o" . obsidian-follow-link-at-point)
  ;; Jump to backlinks
  ("C-c C-b" . obsidian-backlink-jump)
  ;; If you prefer you can use `obsidian-insert-link'
  ("C-c C-l" . obsidian-insert-wikilink)))
#+end_src

#+RESULTS:
: obsidian-insert-wikilink

** =paste-image=
Com ajuda do ChatGPT, fiz uma breve extensão que salva uma imagem do
clipboard em um diretório do workdir, e insere o link a ela tanto em
org quanto em \(\LaTeX\).

#+begin_src emacs-lisp :tangle init.el
(defun paste-image ()
  "Paste an image from the clipboard, let the user choose a directory to save it,
and insert a link to it in the buffer. Supports Org-mode and LaTeX."
  (interactive)
  (let* ((session (getenv "XDG_SESSION_TYPE"))
         (command-header (cond
                          ((string= session "x11")
                           "xclip -selection clipboard -t image/png -o")
                          ((string= session "wayland")
                           "wl-paste --type image/png")
                          (t (error "Unknown session type: %s" session))))
         ;; permite escolher o diretório de destino
         (base-dir (read-directory-name
                    "Escolha o diretório para salvar a imagem: "
                    default-directory nil nil "img/"))
         (_ (make-directory base-dir t))
         (filename (concat (make-temp-name
                            (expand-file-name "img-" base-dir)) ".png"))
         (command (concat command-header " | convert - " (shell-quote-argument filename))))

    (shell-command command)
    (if (file-exists-p filename)
        (cond
         ((derived-mode-p 'org-mode)
          (insert (concat "[[file:" (file-relative-name filename default-directory) "]]"))
          (message "Imagem salva em %s e link inserido (Org-mode)"
                   (file-relative-name filename default-directory)))
         ((derived-mode-p 'latex-mode)
          (insert (format "\\begin{figure}[h]\n\\centering\n\\includegraphics[width=\\linewidth]{%s}\n\\caption{}\n\\label{fig:}\n\\end{figure}"
                          (file-relative-name filename default-directory)))
          (message "Imagem salva em %s e figura LaTeX inserida"
                   (file-relative-name filename default-directory)))
         (t
          (message "Modo atual não é Org nem LaTeX; imagem salva em %s" filename)))
      (message "Falha ao salvar a imagem"))))

#+end_src

#+RESULTS:
: paste-image

** =pdf-tools=
PDFs no emacs? Responsivos, bons e úteis? Sign me in!
#+begin_src emacs-lisp :tangle init.el 
  (use-package pdf-tools
    :hook (pdf-view-mode . blink-cursor-mode)
    :config (add-hook 'pdf-view-mode-hook 'auto-revert-mode)
    :config
    (define-key pdf-view-mode-map (kbd ":") 'pdf-view-goto-page)
    (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
    (define-key pdf-view-mode-map (kbd "C-r") 'isearch-backward)
    (define-key pdf-view-mode-map (kbd "/") 'isearch-forward)
    (define-key pdf-view-mode-map (kbd "?") 'isearch-backward)
    (define-key pdf-view-mode-map (kbd "j") 'pdf-view-next-line-or-next-page)
    (define-key pdf-view-mode-map (kbd "k") 'pdf-view-previous-line-or-previous-page)
    (define-key pdf-view-mode-map (kbd "l") 'image-forward-hscroll)
    (define-key pdf-view-mode-map (kbd "h") 'image-backward-hscroll)
    (define-key pdf-view-mode-map (kbd "J") 'pdf-view-next-page-command)
    (define-key pdf-view-mode-map (kbd "K") 'pdf-view-previous-page-command)
    (define-key pdf-view-mode-map (kbd "TAB") 'pdf-outline)
    (define-key pdf-view-mode-map (kbd "C-S-r") 'pdf-view-midnight-minor-mode)
    (define-key pdf-view-mode-map (kbd "T") 'pdf-view-themed-minor-mode)
    (define-key pdf-view-mode-map (kbd "s") 'pdf-view-fit-width-to-window)
    (define-key pdf-view-mode-map (kbd "a") 'pdf-view-fit-page-to-window)
    :config (setq pdf-view-midnight-colors '("#FFBB33" . "#222222")))
  (pdf-loader-install)
#+end_src

#+RESULTS:

** =rainbow-delimiter=
 Colore os delimitadores corretamente.
#+begin_src emacs-lisp :tangle init.el 
  (use-package rainbow-delimiters
    :init( progn (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
                 (add-hook 'LaTeX-mode-hook 'rainbow-delimiters-mode)))
#+end_src
** =rgrep=
Preciso instalar o =rgrep= no emacs para fazer uso do
=consult-ripgrep= ou =projectile-ripgrep=.
#+begin_src emacs-lisp :tangle init.el
  (use-package ripgrep)
#+end_src

** =smartparens=
Abre, fecha e acerta os parênteses automaticamente.
#+begin_src emacs-lisp :tangle init.el 
  (use-package smartparens
    :init (require 'smartparens-config)
    :init (smartparens-global-mode))
#+end_src
** =yasnippet=
Snippets para acelerar a escrita!
#+begin_src emacs-lisp :tangle init.el 
  (add-to-list 'load-path
               "~/.config/emacs/plugins/yasnippet")
  (use-package yasnippet
    :init (yas-global-mode))
  (use-package yasnippet-snippets)
  ;; (use-package ivy-yasnippet)
#+end_src
* language specifics
** LaTeX
Aqui vou colocar algumas coisas de LaTeX e mudar para outro lugar
depois. 
*** =latex-extra=
Adiciona comandos extras para o =LaTeX-mode=.
#+begin_src emacs-lisp :tangle init.el
(use-package latex-extra)
#+end_src

#+RESULTS:

*** =AUCTex=
AUCTex organiza algumas coisas extras para o compilador do LaTeX e
permite mais funções. Antes, estava *tudo* fora do =use-package=, vou
tentar deixar lá dentro. Se der pau, eu arrumo.
#+begin_src emacs-lisp :tangle init.el 
  (use-package auctex
    :init (require 'latex)
    :bind (:map LaTeX-mode-map
                ("C-S-e" . latex-math-from-calc)
  	      (:map org-mode-map
  		    ("C-S-e" . latex-math-from-calc)))
    :config
    ;; Format math as a Latex string with Calc
    (defun latex-math-from-calc ()
      "Evaluate `calc' on the contents of line at point."
      (interactive)
      (cond ((region-active-p)
             (let* ((beg (region-beginning))
                    (end (region-end))
                    (string (buffer-substring-no-properties beg end)))
               (kill-region beg end)
               (insert (calc-eval `(,string calc-language latex
                                            calc-prefer-frac t
                                            calc-angle-mode rad)))))
            (t (let ((l (thing-at-point 'line)))
                 (end-of-line 1) (kill-line 0) 
                 (insert (calc-eval `(,l
                                      calc-language latex
                                      calc-prefer-frac t
                                      calc-angle-mode rad)))))))
    :config (setq TeX-auto-save t)
    (setq TeX-parse-self t)
    (setq-default TeX-master nil)
    (setq font-latex-fontify-script nil))
#+end_src

#+RESULTS:
: latex-math-from-calc

*** =ReFTeX=
ReFTeX adiciona /keybinds/ para referências em LaTeX.
#+begin_src emacs-lisp :tangle init.el 
  (use-package reftex
    :config (setq reftex-plug-into-AUCTeX t)
            (setq prettify-symbols-unprettify-at-point 'right-edge)
    :hook (TeX-mode . prettify-symbols-mode)
          (LaTeX-mode . LaTeX-math-mode)
          (TeX-mode . outline-minor-mode)
          (TeX-mode . turn-on-reftex))
#+end_src

#+RESULTS:
| turn-on-reftex | outline-minor-mode | prettify-symbols-mode |

Adições para o =LaTeX-math=.
#+begin_src emacs-lisp :tangle init.el
  (define-key LaTeX-math-mode-map (kbd "` o *") 'LaTeX-math-otimes)
  (define-key LaTeX-math-mode-map (kbd "` o .") 'LaTeX-math-odot)
  (defun LaTeX-math-mathcal (key dol)
    (interactive "*c\nP")
    (insert (format "\\mathcal{%s}" (char-to-string key))))
  (define-key LaTeX-math-mode-map (kbd "` c") 'LaTeX-math-mathcal)
#+end_src

*** TODO =lazytab=
=lazytab= é capaz de criar matrizes, em LaTeX, utilizando =TAB= e a
sintaxe de =org-mode=. Pode precisar de conserto.
#+begin_src emacs-lisp :tangle init.el
  (use-package lazytab
    :straight (:host github :repo  "karthink/lazytab" :branch "master")
    :hook ((LaTeX-mode . lazytab-mode) (LaTeX-math-mode . orgtbl-mode)))
#+end_src

** =clojure=
Modo de programação em ~clojure~.
#+begin_src emacs-lisp :tangle init.el
  (use-package clojure-ts-mode)
#+end_src

#+RESULTS:

O ~cider~ é um modo iterativo de clojure em emacs, permitindo executar
expressão a expressão.
#+begin_src emacs-lisp :tangle init.el
  (use-package cider)

#+end_src

#+RESULTS:


** =julia=
#+begin_src emacs-lisp :tangle init.el
  (use-package julia-repl)
  (use-package julia-mode
    :mode ("\\.jl\\'" . julia-mode)
    :interpreter ("julia" . julia-mode)
    :bind
    (:map julia-mode-map
          ("C-c C-z" . julia-repl)
          ("C-c C-c" . julia-repl-send-buffer)
          ("C-<return>" . julia-repl-send-region-or-line)
          ("C-<enter>" . julia-repl-send-region-or-line)
          ("C-c C-d" . julia-repl-doc)))
#+end_src

** =ledger=
=ledger= é onde eu guardo todas as minhas finanças organizadas. É
realmente um baita software.
#+begin_src emacs-lisp :tangle init.el 
  (use-package ledger-mode
    :config (progn (setq ledger-reports
                         (quote
                          (("bal cf" "%(binary) -f %(ledger-file) bal ^Income ^Expenses --real")
                           ("bal nw" "%(binary) -f %(ledger-file) bal ^Assets ^Liabilities --real")
                           ("bal precos" "%(binary) -f %(ledger-file) --price-db btc_price.db --price-db comm.db -V bal")
                           ("bal" "%(binary) -f %(ledger-file) bal")
                           ("reg" "%(binary) -f %(ledger-file) reg")
                           ("reg - price" "%(binary) -f %(ledger-file) reg -V --price-db btc_price.db --price-db comm.db")
                           ("payee" "%(binary) -f %(ledger-file) reg @%(payee)")
                           ("account" "%(binary) -f %(ledger-file) reg %(account)")))))
    :config (setq ledger-post-amount-alignment-column 60)
    :hook (ledger-mode . 
                       (lambda ()
                         (setq-local tab-always-indent 'complete)
                         (setq-local completion-ignore-case t)
                         (setq-local ledger-complete-in-steps t))))
#+end_src

** =nextflow=
No trabalho, talvez seja necessário o uso do [[id:feb39559-bb9d-4c86-88d9-1c6c5ff28e07][Nextflow]], que é uma
linguagem que cria pipelines, útil para desenvolvimento de ciência
reprodutível. 

#+begin_src emacs-lisp :tangle init.el
  (use-package groovy-mode) ;; requisito
  (use-package nextflow-mode
    :straight (:host github :repo "edmundmiller/nextflow-mode" :branch "master")
    :config
    (with-eval-after-load 'eglot
      (add-to-list 'eglot-server-programs
                   '(nextflow-mode . ("nextflow-language-server")))))
#+end_src

#+RESULTS:

** =notmuch=
Cliente de email.
#+begin_src emacs-lisp :tangle init.el 
  (use-package notmuch
    :config (setq notmuch-search-oldest-first nil)
    :bind ("C-c m" . notmuch))
#+end_src

#+RESULTS:
: notmuch


Algumas configurações importantes para enviar email.
#+begin_src emacs-lisp :tangle init.el 
  (setq
   send-mail-function 'smtpmail-send-it
   message-send-mail-function 'smtpmail-send-it
   user-mail-address "nicolas.morazotti@gmail.com"
   smtpmail-starttls-credentials '(("smtp.gmail.com" "587" nil nil))
   smtpmail-default-smtp-server "smtp.gmail.com"
   smtpmail-smtp-server "smtp.gmail.com"
   smtpmail-smtp-service 587
   smtpmail-debug-info t
   starttls-extra-arguments nil
   starttls-gnutls-program "/usr/bin/gnutls-cli"
   starttls-extra-arguments nil
   starttls-use-gnutls t)
#+end_src

Arquivo de assinatura de email.
#+begin_src emacs-lisp :tangle init.el 
(setq message-signature-file "~/.config/emacs/private/signature")
#+end_src

Para pegar links de email e jogar pro =org=, é só digitar =c i=.
#+begin_src emacs-lisp :tangle no
(org-link-set-parameters "notmuch"
			 :follow 'org-notmuch-open
			 :store 'org-notmuch-store-link)

(defun org-notmuch-open (id)
  "Visit the notmuch message or thread with id ID."
  (notmuch-show id))

(defun org-notmuch-store-link ()
  "Store a link to a notmuch mail message."
  (cl-case major-mode
    ('notmuch-show-mode
     ;; Store link to the current message
     (let* ((id (notmuch-show-get-message-id))
	    (link (concat "notmuch:" id))
	    (description (format "Mail: %s" (notmuch-show-get-subject))))
       (org-store-link-props
	:type "notmuch"
	:link link
	:description description)))
    ('notmuch-search-mode
     ;; Store link to the thread on the current line
     (let* ((id (notmuch-search-find-thread-id))
	    (link (concat "notmuch:" id))
	    (description (format "Mail: %s" (notmuch-search-find-subject))))
       (org-store-link-props
	:type "notmuch"
	:link link
	:description description)))))
    
(provide 'org-notmuch)
#+end_src

Alias de alguns emails da UFSCar.
#+begin_src emacs-lisp :tangle init.el
  (setq message-alias-alist
        '(("91103A" . "brunofarias@estudante.ufscar.br,davimerenda@estudante.ufscar.br,erick.cordeiro@estudante.ufscar.br,gabrielsoares@estudante.ufscar.br,giovanacardoso@estudante.ufscar.br,julianopadua@estudante.ufscar.br,luisqueiroz@estudante.ufscar.br,marcoscavalcante@estudante.ufscar.br,murilolc@estudante.ufscar.br,rafael.bissoli@estudante.ufscar.br,vinicius.catoia@estudante.ufscar.br,wadrimabreu@estudante.ufscar.br,alvaroqueiroz@estudante.ufscar.br")
          ("91103F" . "alinecarvalho@estudante.ufscar.br,andreburatini@estudante.ufscar.br,arthurferreira@estudante.ufscar.br,clarissapires@estudante.ufscar.br,danielss@estudante.ufscar.br,dkmurakami@estudante.ufscar.br,campanhadiego@estudante.ufscar.br,felipe.lima@estudante.ufscar.br,grace.rendelmann@estudante.ufscar.br,gustavonogueira@estudante.ufscar.br,joaobrabo@estudante.ufscar.br,jmzgarcia@estudante.ufscar.br,kristinchristianini@estudante.ufscar.br,lana.lemes@estudante.ufscar.br,lucasjora@estudante.ufscar.br,lucasrotiroti@estudante.ufscar.br,lucasminatogawa@estudante.ufscar.br,matteo.calicchio@estudante.ufscar.br,michelle.almeida@estudante.ufscar.br,nicolemessias@estudante.ufscar.br,patriksantosrigon@estudante.ufscar.br,pedropetenon@estudante.ufscar.br,rafaelcouto@estudante.ufscar.br,rafaelleal@estudante.ufscar.br,sophialeoncio@estudante.ufscar.br")
          ("eumesmo" . "nicolas.morazotti@gmail.com")
          ("91103NA" . "eliezerneto@estudante.ufscar.br, julia.mori@estudante.ufscar.br, lucas.mangiaterra@estudante.ufscar.br, matheo@estudante.ufscar.br, mirlenegb@estudante.ufscar.br, pedrobotelho@estudante.ufscar.br, isis.pfeifer@estudante.ufscar.br")))
          #+end_src

#+RESULTS:
: ((91103A . brunofarias@estudante.ufscar.br,davimerenda@estudante.ufscar.br,erick.cordeiro@estudante.ufscar.br,gabrielsoares@estudante.ufscar.br,giovanacardoso@estudante.ufscar.br,julianopadua@estudante.ufscar.br,luisqueiroz@estudante.ufscar.br,marcoscavalcante@estudante.ufscar.br,murilolc@estudante.ufscar.br,rafael.bissoli@estudante.ufscar.br,vinicius.catoia@estudante.ufscar.br,wadrimabreu@estudante.ufscar.br,alvaroqueiroz@estudante.ufscar.br) (91103F . alinecarvalho@estudante.ufscar.br,andreburatini@estudante.ufscar.br,arthurferreira@estudante.ufscar.br,clarissapires@estudante.ufscar.br,danielss@estudante.ufscar.br,dkmurakami@estudante.ufscar.br,campanhadiego@estudante.ufscar.br,felipe.lima@estudante.ufscar.br,grace.rendelmann@estudante.ufscar.br,gustavonogueira@estudante.ufscar.br,joaobrabo@estudante.ufscar.br,jmzgarcia@estudante.ufscar.br,kristinchristianini@estudante.ufscar.br,lana.lemes@estudante.ufscar.br,lucasjora@estudante.ufscar.br,lucasrotiroti@estudante.ufscar.br,lucasminatogawa@estudante.ufscar.br,matteo.calicchio@estudante.ufscar.br,michelle.almeida@estudante.ufscar.br,nicolemessias@estudante.ufscar.br,patriksantosrigon@estudante.ufscar.br,pedropetenon@estudante.ufscar.br,rafaelcouto@estudante.ufscar.br,rafaelleal@estudante.ufscar.br,sophialeoncio@estudante.ufscar.br) (eumesmo . nicolas.morazotti@gmail.com) (91103NA . eliezerneto@estudante.ufscar.br, julia.mori@estudante.ufscar.br, lucas.mangiaterra@estudante.ufscar.br, matheo@estudante.ufscar.br, mirlenegb@estudante.ufscar.br, pedrobotelho@estudante.ufscar.br, isis.pfeifer@estudante.ufscar.br))

** =python=
Para utilizar o interpretador correto, adicionamos isso aqui.
#+begin_src emacs-lisp :tangle init.el
  (use-package python-mode
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("python" . python-mode))
#+end_src

Aqui, vamos importar o =python-black=, que é um linter de código
python, para deixá-lo ao máximo seguindo a PEP8.
#+begin_src emacs-lisp :tangle init.el
  (use-package python-black)
#+end_src

Vamos utilizar também o modo de ambiente virtual do python, =pyvenv=.
#+begin_src emacs-lisp :tangle init.el
  ;; check if pyvenv is enabled
  ;; create a y/n question to use pyvenv whenever opening python files 
  ;; (defun use-pyvenv ()
  ;;   (interactive)
  ;;   (unless (bound-and-true-p pyvenv-virtual-env)
  ;;       (if (y-or-n-p "Use pyvenv? ")
  ;;           (pyvenv-activate (read-directory-name "Enter virtualenv directory: " "~/.anaconda3/envs/" nil nil)))))

  (use-package pyvenv
    :hook (python-mode . pyvenv-mode)
    ;; :hook (python-mode . use-pyvenv)
    )
#+end_src

#+RESULTS:
| pyvenv-mode | eglot-ensure | doom-modeline-env-setup-python |
