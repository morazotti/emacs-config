#+title: Emacs init
#+author: nmorazotti
#+email: nicolas.morazotti@protonmail.ch
#+TODO: TODO(t) IN-PROGRESS(p) | DONE(d) ABANDONED(b)
#+STARTUP: overview
Atualizando e organizando minha config.

* Não sei se coloco
** =emms=
Faz tempo que também não uso o =emms=, /emacs multimedia system/.
Pensei em trocar o /leading chord/ pra outra coisa, parece ique =M-n= é
usado por alguns plugins.
#+begin_src emacs-lisp :tangle exwm.el 
  (use-package emms
    :config
    (require 'emms-setup)
    (require 'emms-player-mpd)
    (emms-all) ; don't change this to values you see on stackoverflow questions if you expect emms to work
    (setq emms-seek-seconds 5)
    (setq emms-player-list '(emms-player-mpd))
    (setq emms-info-functions '(emms-info-mpd))
    (setq emms-player-mpd-server-name "127.0.0.1")
    (setq emms-player-mpd-server-port "6600")
    (emms-toggle-random-playlist)
    (emms-player-mpd-connect)
    :bind					
    ("M-n p" . emms)
    ("M-n b" . emms-smart-browse)
    ("M-n r" . emms-player-mpd-update-all-reset-cache)
    ("M-n ," . emms-player-mpd-previous)
    ("M-n ." . emms-player-mpd-next)
    ("M-n -" . emms-volume-lower)
    ("M-n =" . emms-volume-raise)
    ("M-n SPC" . emms-player-mpd-pause))
#+end_src

* =package=
Carregar o package, adicionar o melpa, carregar =common-lisp=.

#+begin_src emacs-lisp :tangle init.el 
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  (package-initialize)
#+end_src

#+RESULTS:
  
#+begin_src emacs-lisp :tangle init.el 
  (require 'cl-lib)
  (setq warning-minimum-log-level :error)
#+end_src

#+RESULTS:
: :error

* =use-package=

=Boostrap=  do =use-package= para auto-instalar a configuração inteira
sozinho.

#+begin_src emacs-lisp :tangle init.el 
  (unless (package-installed-p 'use-package) 
  (package-refresh-contents)
  (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
  (setq use-package-always-defer t) 
#+end_src

#+RESULTS:
: t

* =straight.el=
O =straight.el= é um package-manager que permite o uso de repositórios
=git= para maior flexibilidade.
#+begin_src emacs-lisp :tangle init.el 
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
  (setq straight-use-package-by-default t)
  (setq straight-disable-byte-compilation t)
#+end_src

#+RESULTS:
: t
* =org=
=org= precisa ser rapidamente carregado para não conflitar com outras coisas.
#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :straight (:type built-in))
#+end_src
** =ox-extra=
Adiciona algumas funcionalidades novas para o org-export, como utilizar
a /headline/ =ignore= para pular a headline sem pular o texto dela na exportação..
#+begin_src emacs-lisp :tangle init.el 
  (use-package org
    ;; :init 
    ;; (defun display-ansi-colors ()
    ;;   "Fixes kernel output in emacs-jupyter"
    ;;   (ansi-color-apply-on-region (point-min) (point-max)))
    ;; :hook
    ;; (org-mode . (lambda () ( (add-hook 'org-babel-after-execute-hook #'display-ansi-colors))))
    :hook (org-mode . my/sane-heading-size)
    :hook (org-mode . org-indent-mode)
    :hook (org-mode . auto-fill-mode)
    :config (setq org-preview-latex-image-directory "/home/nicolas/.cache/ltximg/")
    ;; :defer 7 ; estava ativo, não sei se mantenho
    :bind (:map org-mode-map ("<f7>" . 
                              (lambda()
                                (interactive)
                                (org-export-dispatch 1)))))
  (use-package org-contrib)
  (require 'ox-extra)
  (ox-extras-activate '(latex-header-blocks ignore-headlines))
#+end_src

#+RESULTS:
A função que mantém os /headings/ do =org-mode= constantes:
#+begin_src emacs-lisp :tangle init.el 
  (defun my/sane-heading-size ()
    (dolist
        (face '(org-level-1
                org-level-2
                org-level-3
                org-level-4
                org-level-5
                org-document-title))
      (set-face-attribute face nil :weight 'normal :height 1.0)))
#+end_src

Quero ser capaz de utilizar alguma sintaxe para exportar subfiguras em
LaTeX.
#+begin_src emacs-lisp :tangle init.el
  (org-link-set-parameters
   "subfig"
   :follow (lambda (file) (find-file file))
   :face '(:foreground "chocolate" :weight bold :underline t)
   :display 'full
   :export (lambda (file desc backend)
             (when (eq backend 'latex)
               (if (string-match ">(\\(.+\\))" desc)
                   (concat "\\subfigure[" (replace-regexp-in-string "\s+>(.+)" "" desc) "]"
                           "{\\includegraphics"
                           "["
                           (match-string 1 desc)
                           "]"
                           "{"
                           file
                           "}}")
                 (format "\\subfigure[%s]{\\includegraphics{%s}}" desc file)))))
#+end_src

Seu uso é feito da seguinte maneira:
#+begin_example 
  #+name: fig_name
  #+attr_latex: :options \centering
  #+caption: Figure Caption
  #+begin_figure 
  [[subfig:img1.png][Subcaption 1 >(scale=0.6)]] 
  [[subfig:img2.png][Subcaption 2 >(scale=0.6)]]
  [[subfig:img3.png][Subcaption 3 >(scale=0.6)]]
  #+end_figure
#+end_example
** custom emphasis
Adiciona uma ênfase customizada para o org-mode, que traduz
palavra para fonte em negrito e vermelho.
#+begin_src emacs-lisp :tangle init.el
  ;; Adiciona uma nova entrada para `!` no `org-emphasis-alist`
  (add-to-list 'org-emphasis-alist
               '(! (:weight bold :foreground "red")))

  ;; Atualiza as regexes de ênfase para incluir o novo delimitador `!`
  (org-set-emph-re 'org-emphasis-regexp-components
                   '(" \t('\"{"
                     "- \t.,:!?;'\")}\\["
                     " \t\r\n,\"'"
                     "."
                     1))

  ;; Atualiza o modo org para usar as novas configurações de ênfase
  (org-element-update-syntax)

  ;; Atualiza as palavras-chave de font-lock
  (font-lock-add-keywords 'org-mode
                          '(("\\(!\\)\\([^!]+\\)\\(!\\)"
                             (1 '(:foreground "red" :weight bold) t)
                             (2 '(:foreground "red" :weight bold) 
                             (3 '(:foreground "red" :weight bold) t)))))

#+end_src

#+RESULTS:

** custom ox-extra
Aqui, há uma parte do código que converte =!palavra!= para
=\textcolor{red}{palavra}=
#+begin_src emacs-lisp :tangle init.el
  (defun my-org-latex-filter (text backend info)
    "Replace !word! with \\textcolor{red}{word} in LaTeX export."
    (when (org-export-derived-backend-p backend 'latex)
      (replace-regexp-in-string "!\\(.*?\\)!" "\\\\textcolor{red}{\\1}" text)))

  (add-to-list 'org-export-filter-plain-text-functions
               'my-org-latex-filter)
#+end_src
#+RESULTS:
| my-org-latex-filter |

** =julia=
#+begin_src emacs-lisp :tangle init.el
  (use-package ob-julia
    :straight (:host github :repo "gjkerns/ob-julia" :branch "master")
    :config (setq inferior-julia-program-name "/usr/bin/julia"))
#+end_src

** =jupyter=

Bloco de =jupyter= para executar =python=. 
#+begin_src emacs-lisp :tangle init.el 
  (use-package jupyter
    :init (setq org-image-actual-width 1024)

    ;; preciso fixar o commit, deu problema ano passado
    :straight
    (:host github
           :repo "emacs-jupyter/jupyter"
           :branch "master"
           :commit "f97f4b5d8c83e0b901020f835183dde8a2bf649e"
           )

    :bind ("C-M-s-h" . jupyter-org-hydra/body)
    ;; isso permite o tamanho da imagem ser controlado por #+attr_*
    :config (require 'jupyter-julia)
            (require 'jupyter-python))
#+end_src

#+RESULTS:
: jupyter-org-hydra/body
** =ob-jupyter= em kernel externo
Para acessar o diretório com kernel disponível pelo ~jupyter kernel~
em uma máquina com acesso ~ssh~, podemos utilizar a opção
~:session
[/ssh:[USER@]HOST:]$HOME/.local/share/jupyter/runtime/kernel-<PID>.json~. Contudo,
isso é complicado de escrever, o PID muda sempre que abrirmos um
kernel novo, então dá um trabalhão. Para isso, o [[https://sqrtminusone.xyz/posts/2021-05-01-org-python/][sqrtminusone]] criou um
script que faz isso automaticamente em ~elisp~.

#+begin_src emacs-lisp :tangle init.el
  (defun my/choose-ssh-host (ssh-config-file)
  "Read SSH config file and allow the user to choose a host.
If the chosen host is not 'local', prefix it with '/ssh:<chosen-host>:'."
  (let ((hosts '("local"))
	(kern-dir "~/.local/share/jupyter/runtime/"))  ;; Add the "local" option to the hosts list
    ;; Read the SSH config file
    (with-temp-buffer
      (insert-file-contents ssh-config-file)
      ;; Use regex to find "Host" definitions
      (while (re-search-forward "^Host\\s-+\\(.*\\)" nil t)
        (push (match-string 1) hosts)))
    ;; Use completing-read to select a host
    (let ((chosen-host (completing-read "Choose SSH host: " (reverse hosts))))
         (if (string= chosen-host "local")
              (message kern-dir)
        (message (concat "/ssh:" chosen-host ":" kern-dir))))))

  (defun my/jupyter-runtime-folder ()
    (interactive)
    (expand-file-name (my/choose-ssh-host "~/.ssh/config"))) 

  (defun my/get-open-ports ()
    (mapcar
     #'string-to-number
     (split-string (shell-command-to-string "ss -tulpnH | awk '{print $5}' | sed -e 's/.*://'") "\n")))

  (defun my/list-jupyter-kernel-files ()
    (interactive)
     (mapcar
     (lambda (file) (cons (car file) (cdr (assq 'shell_port (json-read-file (car file))))))
     (sort
      (directory-files-and-attributes (my/jupyter-runtime-folder) t ".*kernel")
      (lambda (x y) (not (time-less-p (nth 6 x) (nth 6 y)))))))

  (defun my/select-jupyter-kernel ()
    (let ((ports (my/get-open-ports))
          (files (my/list-jupyter-kernel-files)))
      (completing-read
       "Jupyter kernels: " files)))
       ;; (seq-filter
       ;;  (lambda (file)
       ;;    (member (cdr file) ports))
       ;;  files))))

  (defun my/insert-jupyter-kernel ()
    "Insert a path to an active Jupyter kernel into the buffer"
    (interactive)
    (insert (my/select-jupyter-kernel)))

  (defun my/jupyter-connect-repl ()
    "Open emacs-jupyter REPL, connected to a Jupyter kernel"
    (interactive)
    (jupyter-connect-repl (my/select-jupyter-kernel) nil nil nil t))

  (defun my/jupyter-qtconsole ()
    "Open Jupyter QtConsole, connected to a Jupyter kernel"
    (interactive)
    (start-process "jupyter-qtconsole" nil "setsid" "jupyter" "qtconsole" "--existing"
                   (file-name-nondirectory (my/select-jupyter-kernel))))

  (defun my/jupyter-cleanup-kernels ()
    (interactive)
    (let* ((ports (my/get-open-ports))
           (files (my/list-jupyter-kernel-files))
           (to-delete (seq-filter
                       (lambda (file)
                         (not (member (cdr file) ports)))
                       files)))
      (when (and (length> to-delete 0)
                 (y-or-n-p (format "Delete %d files?" (length to-delete))))
        (dolist (file to-delete)
          (delete-file (car file))))))
#+end_src

#+RESULTS:
: my/jupyter-cleanup-kernels

Podemos colocar também no cabeçalho a linha
~#+property: header-args:jupyter-python :session [/ssh:[USER@]HOST:]$HOME/.local/share/jupyter/runtime/kernel-<PID>.json~
para inicializar todos os blocos ~jupyter-python~ com essa sessão.
** =tmux=
Permite o uso de =tmux= como execução iterativa de =shell= no
=org-babel=.
#+begin_src emacs-lisp :tangle init.el
  (use-package ob-tmux)
    ;; :config  (setq org-babel-tmux-terminal "/home/nicolas/.local/bin/ob-vterm")
    ;;          (setq org-babel-tmux-terminal-opts nil))
#+end_src

#+RESULTS:
: t

** =babel-mermaid=
O =mermaid= gera um flowchart melhor que o ditaa.
#+begin_src emacs-lisp :tangle init.el
   (use-package ob-mermaid
     :init (setq ob-mermaid-cli-path "/usr/local/bin/mmdc")
     (setq org-babel-default-header-args:mermaid
           (cons
            '(:pupeteer-config-file . "/home/nicolas/.local/src/pupeteer.json")
            (assq-delete-all :pupeteer-config-file
                             org-babel-default-header-args))))
#+end_src

#+RESULTS:
: ((:pupeteer-config-file . /home/nicolas/.local/src/pupeteer.json) (:session . none) (:results . replace) (:exports . code) (:cache . no) (:noweb . no) (:hlines . no) (:tangle . no))

** =org= babel
=org-babel= estende a funcionalidade do =org= para permitir execução de
blocos de código. Vou escolher as linguagens aqui.
#+begin_src emacs-lisp :tangle init.el 
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((C . t)
     (jupyter . t)
     (shell . t)
     (tmux . t)
     (mermaid . t)
     ; (nextflow . t)
     ; (octave , t)
     (latex . t)
     (fortran . t)
     (python . t)
     (ledger . t)))
#+end_src

#+RESULTS:

** =roam=
=org-roam= é um segundo cérebro em =org-mode= que utilizo.
#+begin_src emacs-lisp :tangle init.el 
  (use-package org-roam
    :straight (:host github :repo "org-roam/org-roam" :branch "main")
    :hook
    (after-init . org-roam-db-autosync-mode)
    :init (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory "~/Documents/roam/")
    (org-roam-dailies-directory "~/Documents/roam/projeto-pessoal")
    (org-roam-graph-link-hidden-types ("files" "https" "ref" "fuzzy"))
    :bind (("C-c r f" . org-roam-node-find)
           ("C-c r c" . org-roam-capture)
           ("C-c r b" . org-roam-buffer-toggle)
           ("C-c r I" . org-roam-node-insert-immediate)
           :map org-mode-map
           (("C-c r i" . org-roam-node-insert))))
#+end_src

#+RESULTS:
: org-roam-node-insert

Para inserir um nó sem abri-lo (como na /keychord/ =C-c r I=),
precisamos dessa função.
#+begin_src emacs-lisp :tangle init.el
  (defun org-roam-node-insert-immediate (arg &rest args)
    (interactive "P")
    (let ((args (cons arg args))
          (org-roam-capture-templates
           (list (append (car org-roam-capture-templates)
                         '(:immediate-finish t)))))
      (apply #'org-roam-node-insert args)))
#+end_src

*** =org-roam-ui=
Uma interface gráfica para =org-roam= em [[https://localhost:35901]].

#+begin_src emacs-lisp :tangle init.el
  (use-package org-roam-ui
    :straight
      (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
      :after org-roam
      :config
      (setq org-roam-ui-sync-theme t
            org-roam-ui-follow t
            org-roam-ui-update-on-save t)
      :init (org-roam-ui-mode)

      ;; para compilar  
      :init (setq org-roam-ui-latex-macros
                  '(("\\Tr" . "\\mathrm{Tr}")
                    ("\\tr" . "\\mathrm{Tr}")
                    ("\\dyad" . "\\ket{#1}\\bra{#2}")
                    ("\\order" . "\\mathcal{O}({#1})")
                    ("\\I" . "\\mathbb{I}")
                    ("\\norm" . "\\parallel{#1}\\parallel")
                    ("\\id" . "\\mathbb{I}")
                    ("\\expval" . "\\langle{#1}\\rangle")
                    ("\\dd" . "\\mathrm{d}")
                    ("\\op" . "|{#1}\\rangle\\langle{#2}|")
                    ("\\label" . "\\vphantom")
                    ("\\dv" . "\\frac{\\mathrm{d}{#1}}{\\mathrm{d}{#2}}")
                    ("\\olra" . "\\overleftrightarrow{#1}"))))
  (setq org-roam-ui-open-on-start nil)
#+end_src

#+RESULTS:

** IN-PROGRESS =delve=
Delve é um /dashboard/ para caracterizar alguns arquivos seguindo a
metodologia de notas que eu estava olhando. Não tenho certeza ainda.
#+begin_src emacs-lisp :tangle init.el
  (use-package delve
    :straight (:repo "publicimageltd/delve"
                     :host github
                     :type git)
    :after (org-roam)
    ;; this is necessary if use-package-always-defer is true
    :demand t
    :bind
    ;; the main entry point, offering a list of all stored collections
    ;; and of all open Delve buffers:
    (("<f12>" . delve))
    :config
    ;; set meaningful tag names for the dashboard query
    (setq delve-dashboard-tags '("vida" "trabalho" "ilustracao" "blackgenn"))
    ;; optionally turn on compact view as default
    (add-hook #'delve-mode-hook #'delve-compact-view-mode)
    ;; turn on delve-minor-mode when Org Roam file is opened:
    (delve-global-minor-mode))
#+end_src

#+RESULTS:
: delve

Estou finalmente entendendo como ele funciona. Estou gostando.
** =org-ref=
Referências a-la LaTeX /no org-mode/!  A maior parte das configurações
eram importantes no doutorado, mas vou manter a maioria das coisas aqui.
#+begin_src emacs-lisp :tangle init.el 
  (use-package org-ref
    :hook (org-mode . (lambda () (require 'org-ref)))
    ;; :init (require 'org-ref-ivy)
    ;; :config (require 'org-ref-ivy)
    ;; (load-file "~/.config/emacs/straight/build/org-ref/org-ref-ivy.el") ;; talvez nao precise
    :config (setq reftex-default-bibliography '("~/Dropbox/referencias.bib")
                  bibtex-completion-bibliography "~/Dropbox/referencias.bib"
                  bibtex-completion-notes-path "~/Documents/roam/"
                  bibtex-completion-library-path "~/Documents/my_lib/pdfs/"
                  org-latex-listings 'minted
                  ;; org-latex-packages-alist '(("" "minted" "bbm") ("" "physics" t) ("AUTO" "babel" t ("pdflatex" "xelatex" "lualatex")))
                  org-latex-packages-alist '(("" "physics" t))
                  org-latex-pdf-process '("latexmk -shell-escape -bibtex -interaction=nonstopmode -f -pdfxe -8bit %f")
                  org-latex-prefer-user-labels t
                  org-src-fontify-natively t
                  org-confirm-babel-evaluate nil
                  org-format-latex-options '(:foreground default
                                             :background default
                                             :scale 1.6
                                             :html-foreground "Black"
                                             :html-background "Transparent"
                                             :html-scale 1.0
                                             :matchers ("begin" "$1" "$" "$$" "\\(" "\\[" ))
                  org-src-window-setup 'current-window)
              (setq org-file-apps '((auto-mode . emacs)
                                    (directory . emacs)
                                    (\.mm\' . default)
                                    (\.x?html?\' . default)
                                    (\.pdf\' . emacs)))

    ;; agora que terminei o doutorado, acho que isso aqui não vai ser importante.
    ;; :config (add-to-list 'org-latex-classes
    ;;                      '("uspsc"
    ;;                        "\\documentclass{USPSC-classe/USPSC}"
    ;;                        ("\\chapter{%s}" . "\\chapter*{%s}")
    ;;                        ("\\section{%s}" . "\\section*{%s}")
    ;;                        ("\\subsection{%s}" . "\\subsection*{%s}")
    ;;                        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
    ;;                        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
    :bind (("C-c C-]" . org-ref-insert-link)
           ("C-c )" . org-ref-insert-ref-link)))
#+end_src

#+RESULTS:
: org-ref-insert-ref-link

Para utilizar =org-roam= e =org-ref= em conjunto, precido do
=org-roam-bibtex=. Ele permite criar notas de pdfs diretamente no
=org-roam=.
#+begin_src emacs-lisp :tangle init.el
    (use-package biblio)
#+end_src
#+begin_src emacs-lisp :tangle init.el
    (use-package org-roam-bibtex
      :ensure t
      :after (org-roam)
      :load-path "~/Documents/roam/" 
      :config (require 'org-ref)
      :init (org-roam-bibtex-mode))
#+end_src

** =org-agenda=
=org-agenda= é uma poderosa agenda que utiliza todos os arquivos
selecionados para organizar o dia-a-dia.
#+begin_src emacs-lisp :tangle init.el 
    (setq org-directory "/home/nicolas/.config/emacs/private/org")
    (setq org-default-notes-file (concat org-directory "/notes.org"))
    (setq org-agenda-files (list (concat org-directory "/tasks.org")
                                 (concat org-directory "/opusdei.org")
                                 (concat org-directory "/blackgenn.org")
                                 ;; (concat org-directory "/planodevida.org")
                                 (concat org-directory "/notes.org")))
    (global-set-key (kbd "C-c c") 'org-capture)
    (global-set-key (kbd "C-c l") 'org-store-link)
    (global-set-key (kbd "C-c a") 'org-agenda)
#+end_src

#+RESULTS:
: org-agenda

Essa agenda aqui tem algumas informações a mais que a agenda padrão do emacs.
#+begin_src emacs-lisp :tangle init.el 
(defun air-org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.

PRIORITY may be one of the characters ?A, ?B, or ?C."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-value (* 1000 (- org-lowest-priority priority)))
        (pri-current (org-get-priority (thing-at-point 'line t))))
    (if (= pri-value pri-current)

        subtree-end
      nil)))
  (setq org-agenda-custom-commands
        '(("c" "Simple agenda view"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-priority unfinished tasks:")))
            (agenda "")
            (alltodo ""((org-agenda-skip-function
                     '(or (air-org-skip-subtree-if-priority ?A)
                          (org-agenda-skip-if nil '(scheduled deadline))))))))))
#+end_src

*** =super-agenda=
=org-super-agenda= parece bastante útil, mas não tenho nada
configurado. Ver [[https://github.com/alphapapa/org-super-agenda/blob/master/examples.org#feature-examples][aqui]].
#+begin_src emacs-lisp :tangle init.el
  (use-package org-super-agenda
    :init (org-super-agenda-mode 1)
    ;; :init (setq initial-buffer-choice (lambda () (get-buffer "*Org Agenda*")))
    ;; organização por grupos utilizando a propriedade =:agenda-group:=
    :config (setq org-super-agenda-groups
                '((:auto-property "ProjectId")
                  (:name "blackgenn"
                         :scheduled today)
                  (:name "emacs" :tag "emacs")
                  (:name "books"
                         :and (:tag "book")))))
#+end_src

#+RESULTS:
: t

** IN-PROGRESS =capture=
=org-capture= nos permite tomar notas rapidamente. 
#+begin_src emacs-lisp :tangle init.el 
    (setq org-capture-templates
          '(("n" "Notes" entry (file+headline "/home/nicolas/.config/emacs/private/org/notes.org" "Unsorted")
             "* UNSEEN %?\n")
            ("g" "Goals" entry (file+headline "/home/nicolas/.config/emacs/private/org/goals.org" "Unsorted")
             "* TODO %?\n")
            ("i" "Inbox" entry (file+headline "/home/nicolas/.config/emacs/private/org/notes.org" "Inbox")
             "* TODO <%<%Y-%m-%d %H:%M:%S>> \n %?\n")
  	  ("t" "Tasks" entry (file+headline "/home/nicolas/.config/emacs/private/org/tasks.org" "Tarefas")
             "* TODO %?\n")))
#+end_src

#+RESULTS:
| n | Notes | entry | (file+headline /home/nicolas/.config/emacs/private/org/notes.org Unsorted) | * UNSEEN %?                   |
| g | Goals | entry | (file+headline /home/nicolas/.config/emacs/private/org/goals.org Unsorted) | * TODO %?                     |
| i | Inbox | entry | (file+headline /home/nicolas/.config/emacs/private/org/notes.org Inbox)    | * TODO <%<%Y-%m-%d %H:%M:%S>> |

** =org-modern=
Deixa o =org-mode= com uma aparência mais moderna.
#+begin_src emacs-lisp :tangle init.el
  (use-package org-modern
    :straight (:host github :repo "minad/org-modern" :branch "main")
    :config (setq org-modern-table nil)
    :hook (org-mode . org-modern-mode))	
#+end_src

#+RESULTS:
| org-ref-org-menu | delve--maybe-activate-minor-mode | org-cdlatex-mode | org-modern-mode | (lambda nil (require 'org-ref)) | jupyter-org-interaction-mode | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-fold-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | auto-fill-mode | org-indent-mode | my/sane-heading-size | org-babel-jupyter-make-local-aliases |

** =org-cdlatex=
A biblioteca =org-cdlatex= adiciona algumas opções para agilizar a
escrita matemática em documentos =org=.

#+begin_src emacs-lisp :tangle init.el
    (use-package cdlatex
      :hook (org-mode . org-cdlatex-mode)

      ;; comandos extras
      :config (add-to-list 'cdlatex-math-modify-alist '(115 "\\mathscr" nil t nil nil))
              (add-to-list 'cdlatex-math-modify-alist '(66 "\\mathbb" nil t nil nil))
              (add-to-list 'cdlatex-math-modify-alist '(107 "\\mathfrak" nil t nil nil))
              (add-to-list 'cdlatex-math-symbol-alist '(42 ("\\times" "\\otimes")))
              (add-to-list 'cdlatex-math-symbol-alist '(100 ("\\delta" "\\partial" "^{\\dag}")))
              (add-to-list 'cdlatex-math-symbol-alist '(46 ("\\cdot" "\\odot")))
              (cdlatex-reset-mode))
#+end_src

* aparência
Aqui vou definir as coisas importantes para a aparência. 
** fonte

#+begin_src emacs-lisp :tangle init.el 
  (setq default-font "Ligamonacop 12")
  (set-frame-font default-font nil t)
  (setq default-frame-alist '((font . "Ligamonacop 12")))
#+end_src

#+RESULTS:
: ((font . Ligamonacop 14))
** variable pitch
Adiciona o modo =variable pitch=, permitindo a fonte variar no buffer
de org. Contudo, configuro algumas das fontes para permanecer monospaced.
#+begin_src emacs-lisp :tangle init.el
  (variable-pitch-mode 1)
  (set-face-attribute 'org-table nil :family "Ligamonacop")
  (set-face-attribute 'org-block nil :family "Ligamonacop")
#+end_src

#+RESULTS:
** prettify lambda
Para escrever \lambda ao invés de lambda no =elisp=, mas sem perder o texto correto.
#+begin_src emacs-lisp :tangle init.el
  (defun my-pretty-lambda ()
    "make some word or string show as pretty Unicode symbols"
    (setq prettify-symbols-alist '(
            ("lambda" . 955))))
  (add-hook 'emacs-lisp-hook 'my-pretty-lambda)
  (global-prettify-symbols-mode 1)
#+end_src

#+RESULTS:
: t

** =all-the-icons=
=all-the-icons= é um pacote que adiciona ícones nas coisas do =emacs=.
#+begin_src emacs-lisp :tangle init.el 
  (use-package all-the-icons
    :straight (:host github :repo "domtronn/all-the-icons.el" :branch "master"))

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src
** tema

Instalando alguns temas pra poder escolher.

#+begin_src emacs-lisp :tangle init.el 
  (use-package base16-theme)
  (use-package doom-themes)
  (use-package modus-themes
    :straight (:host gitlab :repo "protesilaos/modus-themes" :branch "main"))
  (defvar my/theme 'doom-laserwave) ;;anterior: doom-material-dark
  (load-theme my/theme t nil)
#+end_src

#+RESULTS:
: t

** outras coisas menores
#+begin_src emacs-lisp :tangle init.el 
  (global-hl-line-mode t)
  (setq font-latex-fontify-script nil)
  (scroll-bar-mode -1)
  (set-fringe-mode 10)
  (setq visual-bell t)
  (show-paren-mode t)
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (setq ispell-dictionary "pt_BR")
  (put 'narrow-to-region 'disabled nil) ;; tira o aviso de narrow-to-region
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  ;; (add-hook 'text-mode-hook 'display-line-numbers-mode)
#+end_src

** ligature

#+begin_src emacs-lisp :tangle init.el
(use-package ligature
  :config
  ;; Enable the "www" ligature in every possible major mode
  (ligature-set-ligatures 't '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  ;; Enable all Cascadia Code ligatures in programming modes
  (ligature-set-ligatures 'org-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "__" "~~" "(*" "*)"))
  (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "__" "~~" "(*" "*)"))
  ;; Enables ligature checks globally in all buffers. You can also do it
  ;; per mode with `ligature-mode'.
  (global-ligature-mode t))
#+end_src

#+RESULTS:

** =doom-modeline=
#+begin_src emacs-lisp :tangle init.el
    (use-package doom-modeline
      :straight (:host github :repo "seagle0128/doom-modeline" :branch "master")
      :config (setq doom-modeline-buffer-file-name-style 'buffer-name)
  	     (setq doom-modeline-buffer-encoding nil)
      :config (add-hook 'after-make-frame-functions (lambda (frame)
                                                      (setq doom-modeline-icon t))))
    (doom-modeline-mode)
#+end_src

#+RESULTS:
: t

* QoL
Pacotes e configurações que utilizo no dia-a-dia de qualidade de
vida. Inclue travas, algumas opções menos relevantes.
** auto-save-disable
Auto-save do =emacs= adiciona um bocado de lixo no diretório, que
geralmente não faz diferença.
#+begin_src emacs-lisp :tangle init.el 
 (setq make-backup-files nil)
 (setq auto-save-default nil)
#+end_src
** scratch buffer
Mexendo um pouco no buffer =*scratch*=. Quero mantê-lo sempre aberto.
#+begin_src emacs-lisp :tangle init.el 
 (with-current-buffer (get-buffer-create "*scratch*"))
   (lisp-interaction-mode)
   (make-local-variable 'kill-buffer-query-functions)
   (add-hook 'kill-buffer-query-functions 'kill-scratch-buffer)

 (defun kill-scratch-buffer ()
   ;; The next line is just in case someone calls this manually
   (set-buffer (get-buffer-create "*scratch*"))
   ;; Kill the current (*scratch*) buffer
   (remove-hook 'kill-buffer-query-functions 'kill-scratch-buffer)
   (kill-buffer (current-buffer))
   ;; Make a brand new *scratch* buffer
   (set-buffer (get-buffer-create "*scratch*"))
   (insert initial-scratch-message)  
   (lisp-interaction-mode)
   (make-local-variable 'kill-buffer-query-functions)
   (add-hook 'kill-buffer-query-functions 'kill-scratch-buffer)
   ;; Since we killed it, don't let caller do that.
   nil)
#+end_src 
** =yes-or-no= to =y-or-n=
#+begin_src emacs-lisp :tangle init.el 
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
** camelCase como duas palavras
#+begin_src emacs-lisp :tangle init.el 
(global-subword-mode 1)
#+end_src
** seguir o split da janela
Quando separamos uma janela, ele segue a janela automaticamente. Muito útil.
#+begin_src emacs-lisp :tangle init.el 
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+end_src  
** =revert-buffer=
Keybind para refrescar a janela.
#+begin_src emacs-lisp :tangle init.el 
(global-set-key (kbd "<f5>") 'revert-buffer)
#+end_src
** definir =auto-fill=
#+begin_src emacs-lisp :tangle init.el 
  (setq fill-column 72)
#+end_src
** =abbrev-mode=
O =abbrev= funciona como o =yasnippet=, mas para pequenos termos:
serve para corrigir typos, abreviar expressões com siglas, entre
outros. Poderia ter usado bem no doutorado, mas nunca parei para configurar.
#+begin_src emacs-lisp :tangle init.el
(setq-default abbrev-mode t)
#+end_src

** =drag-stuff=
Me permite arrastar regiões, palavras e linhas por aí.
#+begin_src emacs-lisp :tangle init.el 
  (use-package drag-stuff
    :config (drag-stuff-global-mode t)
    :bind (("<M-up>" . drag-stuff-up)
	   ("<M-down>" . drag-stuff-down)
	   ("<M-left>" . drag-stuff-left)
	   ("<M-right>" . drag-stuff-right))
  )
#+end_src
** =expand-region=
=expand-region= vai selecionando o texto por unidades semânticas:
palava, frase, parágrafo, etc.
#+begin_src emacs-lisp :tangle init.el 
  (use-package expand-region
    :bind ("C-=" . er/expand-region)
    )
#+end_src
** =hide-show-mode=
Permite ocultar blocos dentro de códigos. Acessível pelos comandos
diretos do =vim=: =zr= (show-all), =zm= (fold-all), =zo= (show-this) e
=zc= (fold-this).
#+begin_src emacs-lisp :tangle init.el
  (add-hook 'prog-mode-hook 'hs-minor-mode)
#+end_src

#+RESULTS:
| hs-minor-mode | rainbow-delimiters-mode | copilot-mode | display-line-numbers-mode |

** =Ibuffer=
=Ibuffer= é uma interface customizável para a edição de buffers.
#+begin_src emacs-lisp :tangle init.el 
  (use-package ibuffer
    :bind  ("C-x C-b" . ibuffer)
    :config (setq ibuffer-saved-filter-groups
          (quote (("default"
                   ("dired" (mode . dired-mode))
                   ("org" (mode . org-mode))
  		 
                   ("programming" (or
                                   (mode . sh-mode)
                                   (mode . c-mode)
                                   (mode . python-mode)
                                   (mode . c++-mode)))
                   ("latex" (mode . latex-mode))
                   ("document" (mode . pdf-view-mode))
                   ("image" (mode . image-mode)) 
                   ("magit" (name . "^\\Magit.*"))
                   ("IRC" (mode . erc-mode))
                   ("notmuch" (or
                               (name . "^.*otmuch.*$")
                               (mode . notmuch-hello-mode)
                               (mode . notmuch-search-mode)
                               (mode . notmuch-show-mode)
                               (mode . notmuch-tree-mode)
                               (mode . notmuch-message-mode)))
                   ("ledger" (or (mode . ledger-mode) (mode . ledger-report-mode)))
                   ("emms" (name . "^\\*EMMS.*"))
                   ("emacs" (or
                             (name . "^\\*scratch\\*$")
                             (name . "^\\*Messages\\*$")))
                   ))))
    :config (add-hook 'ibuffer-mode-hook
              (lambda ()
                (ibuffer-auto-mode 1)
                (ibuffer-switch-to-saved-filter-groups "default")))
    :config (setq ibuffer-show-empty-filter-groups nil)
    :config (setq ibuffer-expert t)
    :hook (ibuffer-mode . (lambda ()
      (ibuffer-projectile-set-filter-groups)
      (unless (eq ibuffer-sorting-mode 'alphabetic)
        (ibuffer-do-sort-by-alphabetic)))))
#+end_src
** navegacao
Vou utilizar =vertico= e =marginalia= para movimentação pelos
documentos, organização do minibuffer. Preciso ativar o =ivy-mode= para
que funcione bem o =ledger=.
*** =ace-window=
Se o =avy= faz milagre /inbuffer/, o =ace= faz entre /windows/.
#+begin_src emacs-lisp :tangle init.el 
  (use-package ace-window
    :bind ("C-x o" . ace-window)
    :bind ("M-p" . other-window))
#+end_src
*** =avy= e =ivy=
Duas funções que gosto bastante: =avy= permite pular para o
caractere/linha com combinações de caracteres, e =ivy= é importante pro
=ledger=.
#+begin_src emacs-lisp :tangle init.el 
  (use-package avy
    :config (setq avy-keys '(?a ?r ?s ?t ?n ?e ?i ?o))
    :bind (("M-s M-s" . avy-goto-char)
           ("M-g M-g" . avy-goto-line)))  
#+end_src

#+RESULTS:
: avy-goto-line

#+begin_src emacs-lisp :tangle init.el
  ;; (use-package ivy
  ;;   :config (ivy-mode 1) )
#+end_src

*** =consult=
=consult= estende alguns comandos padrões do =emacs=.
#+begin_src emacs-lisp :tangle init.el
  ;; Example configuration for Consult
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings in `mode-specific-map'
           ("C-c M-x" . consult-mode-command)
           ;; ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ;; ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ([remap Info-search] . consult-info)
           ;; C-x bindings in `ctl-x-map'
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings in `goto-map'
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-make)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ;; ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-find)
           ("M-s D" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key "M-.")
    ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; "C-+"

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; By default `consult-project-function' uses `project-root' from project.el.
    ;; Optionally configure a different project root function.
    ;;;; 1. project.el (the default)
    ;; (setq consult-project-function #'consult--default-project--function)
    ;;;; 2. vc.el (vc-root-dir)
    ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
    ;;;; 3. locate-dominating-file
    ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
    ;;;; 4. projectile.el (projectile-project-root)
    ;; (autoload 'projectile-project-root "projectile")
    ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
    ;;;; 5. No project support
    ;; (setq consult-project-function nil)
    )
#+end_src

*** COMMENT =embark=

=embark= adiciona um dwim helper no =C-.=
#+begin_src emacs-lisp :tangle init.el
  (use-package embark
    :demand t				;
    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

    :init

    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    ;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
    ;; strategy, if you want to see the documentation from multiple providers.
    (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
    ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

    :config

    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :ensure t ; only need to install it, embark loads it after consult if found
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

#+RESULTS:
| consult-preview-at-point-mode |

*** =marginalia=
=marginalia= adiciona informação no minibuffer.
#+begin_src emacs-lisp :tangle init.el
  (use-package marginalia
      :init (marginalia-mode))
#+end_src

*** =orderless=
=orderless= adiciona completion fuzzy.
#+begin_src emacs-lisp :tangle init.el
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic flex))
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

*** =vertico=
=vertico= é o novo =helm=, =ido=, =ivy= etc. Está sendo bastante útil.
#+begin_src emacs-lisp :tangle init.el
  (use-package vertico
    :init (vertico-mode)
    :init (vertico-multiform-mode)
    :straight (:files (:defaults "extensions/*"))
    :bind ( :map vertico-map
            ("RET" . vertico-directory-enter)
            ("DEL" . vertico-directory-delete-char)
            ("M-DEL" . vertico-directory-delete-word))
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)
    :config (setq read-file-name-completion-ignore-case t
                  read-buffer-completion-ignore-case t
                  completion-ignore-case t))
#+end_src

** =transpose-frame=
Rotaciona as janelas do frame, útil se ele particionou errado.
#+begin_src emacs-lisp :tangle init.el
(use-package transpose-frame)
#+end_src

#+RESULTS:

** =pass=
O Ubuntu não se dá bem com pass, e estou cansado de autocomplete no
terminal. Vou usar direto no =emacs= mesmo, pelo menos lá dá menos problema.
#+begin_src emacs-lisp :tangle init.el
  (use-package pass)
  (use-package ivy-pass
    :bind ("s-R" . ivy-pass))
#+end_src

#+RESULTS:
: ivy-pass

** =undo-tree=
=undo-tree= é uma árvore de =undo/redo=, parecendo branches de git.
#+begin_src emacs-lisp :tangle init.el 
  (use-package undo-tree
    :config (global-undo-tree-mode 1))
#+end_src

** =vterm=
O melhor terminal dentro do =emacs=, de disparada.
#+begin_src emacs-lisp :tangle init.el 
  (use-package vterm
    :after multi-vterm
    :init (setq vterm-shell "zsh")

    ;; deixar o vterm na parte de baixo da tela
    :config (add-to-list 'display-buffer-alist
                         '("\*vterm\*"
                           (display-buffer-in-side-window)
                           (window-height . 0.25)
                           (side . bottom)
                           (slot . 0))))
    (use-package vterm-toggle
      :bind ("s-t" . vterm-toggle))
  #+end_src

#+RESULTS:
: vterm-toggle

Tem até como usar como multiplexer com o =multi-vterm=.
#+begin_src emacs-lisp :tangle init.el
  (use-package multi-vterm)
#+end_src

#+RESULTS:
: t

** =winner-mode=
Ele salva modificações de janela pra poder fazer e desfazer as coisas.
#+begin_src emacs-lisp :tangle init.el
  (winner-mode)
#+end_src
** which-key
Descreve os possíveis comandos a partir de um /key-chord/ parcial.
#+begin_src emacs-lisp :tangle init.el 
  (use-package which-key
    :init (which-key-mode))
#+end_src
** =tree-sitter=
Sistema de parse para linguagens de programação mais recente que regex-based. 
#+begin_src emacs-lisp :tangle init.el
  (use-package tree-sitter)
#+end_src

** =centaur-tabs=
Adiciona abas no =emacs=. Eu tenho o costume de usar, mas não sei se faz
toda essa diferença.
#+begin_src emacs-lisp :tangle no
  (use-package centaur-tabs
    :demand
    :config
    (centaur-tabs-mode t)
    (setq centaur-tabs-style "bar")
    (setq centaur-tabs-set-icons t)
    (setq centaur-tabs-gray-out-icons 'buffer)
    (setq centaur-tabs-set-bar 'over)
    (setq centaur-tabs-set-modified-marker t)
    (setq centaur-tabs-cycle-scope 'tabs)
    (setq centaur-tabs-label-fixed-length 8)
    :bind
    ("C-<tab>" . centaur-tabs-forward)
    ("C-<iso-lefttab>" . centaur-tabs-backward)
    :hook (vterm-mode . centaur-tabs-local-mode)
    (ein:notebook-mode . centaur-tabs-local-mode)
    (ein:notebooklist-mode . centaur-tabs-local-mode))
#+end_src

#+RESULTS:
: centaur-tabs-backward

* features
** COMMENT =dashboard=
Cria um dashboard das informações recentes relevantes.
#+begin_src emacs-lisp :tangle init.el 
  (use-package dashboard
    :init (setq dashboard-startup-banner "~/.config/emacs/private/img/ihs2.png") 
    ;; :init (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
    :init (dashboard-setup-startup-hook)
    :init (add-to-list 'recentf-exclude (recentf-expand-file-name "~/.config/emacs/private/*" ))
    :config (setq dashboard-banner-logo-title "Iesu Hominum Salvator"
                  dashboard-items '(
                                    ;; (recents  . 5)
                                    (bookmarks . 5)
                                    (projects . 5)
                                    (agenda . 5)
                                          ;(registers . 5)
                                    )
                   dashboard-footer-messages 'nil ;AD MAIOREM DEI GLORIAM🇻🇦")
                   dashboard-footer-icon "🇻🇦"
                   dashboard-set-heading-icons t
                   dashboard-set-file-icons t
                   ;; (setq dashboard-set-init-info nil)
                   dashboard-center-content t))
#+end_src

#+RESULTS:
: t
** =copilot=
Podemos configurar o uso do copilot, do github, aqui no emacs. Para
isso, preciso do login do github da BlackGenn.
#+begin_src emacs-lisp :tangle init.el
  (use-package copilot
    :straight (:host github :repo "copilot-emacs/copilot.el" :files ("*.el"))
    :hook (prog-mode . copilot-mode)
    :bind (:map copilot-completion-map ("<tab>" . copilot-accept-completion)
                                 ("TAB" . copilot-accept-completion))
    :init (copilot-install-server)
    :ensure t)
#+end_src

#+RESULTS:
: copilot-accept-completion

** =corfu=
Autocompletion.
#+begin_src emacs-lisp :tangle init.el
  (use-package corfu
   :init (global-corfu-mode))
#+end_src

** =company=
#+begin_src emacs-lisp :tangle init.el
    (use-package company
      :hook (prog-mode . company-mode))
#+end_src

#+RESULTS:
| company-mode | rainbow-delimiters-mode | copilot-mode | hs-minor-mode | display-line-numbers-mode |

** =dired=
Um pouco de customização e extensão do =dired= não faz mal nenhum.
#+begin_src emacs-lisp :tangle init.el 
  (use-package dired-plus
    :straight (:host github :repo "emacsmirror/dired-plus"
                     :branch "master")
    :bind ("C-x C-j" . dired-jump)
    :config (setq dired-kill-when-opening-new-dired-buffer t)
    :init (setq dired-listing-switches "-glh --group-directories-first")
    (setq dired-dwim-target t))
#+end_src
=dired-preview= é capaz de gerar /preview/ de arquivos compatíveis - texto,
imagem.
#+begin_src emacs-lisp :tangle init.el 
  (use-package dired-preview
    :init (dired-preview-global-mode 1)
    :config (setq dired-preview-delay 0.7)
    (setq dired-preview-ignored-extensions-regexp
  	(concat "\\."
              "\\(mkv\\|webm\\|mp4\\|mp3\\|ogg\\|m4a"
              "\\|gz\\|zst\\|tar\\|xz\\|rar\\|zip"
              "\\|iso\\|epub\\)")))
#+end_src

** =projectile=
=projectile= é um pacote que unifica os projetos e permite toda uma
coerência entre os arquivos do mesmo.
#+begin_src emacs-lisp :tangle init.el 
  (use-package projectile
    :config
    (projectile-global-mode 1) 
    (setq projectile-completion-system 'ivy)
    :bind-keymap 
    ("C-c p" . projectile-command-map))

  (use-package ibuffer-projectile) ;; agrupa buffers do mesmo projeto
#+end_src
** =magit=
Uma porcelana =git= que é realmente de outro mundo.
#+begin_src emacs-lisp :tangle init.el 
  (use-package with-editor
    :straight nil)
  (use-package magit
    :bind ("C-x g" . magit-status))
#+end_src
** =forge=
Interação com GitHub, com pull request, issues etc.
#+begin_src emacs-lisp :tangle init.el
  (use-package forge)
#+end_src

#+RESULTS:

** =treemacs=
=treemacs= é uma sidebar de árvore de arquivos.
#+begin_src emacs-lisp :tangle init.el 
  (use-package treemacs
    :bind ("C-c j" . treemacs))
  (use-package treemacs-magit)
  (use-package treemacs-projectile)
  (use-package treemacs-evil)
#+end_src

#+RESULTS:

** =eglot=
=eglot= é um LSP-like do próprio emacs.
#+begin_src emacs-lisp :tangle init.el
  (use-package eglot
  :ensure t
  :defer t
  :hook
  (python-mode . eglot-ensure)
  (javascript-mode . eglot-ensure)
  (julia-mode . eglot-ensure)
  (java-mode . eglot-ensure))
#+end_src
Para acelerar o eglot, utilizamos =eglot-booster=. Precisamos
adicionar o diretório =.local/bin= no =PATH= do emacs.
#+begin_src emacs-lisp :tangle init.el
  (add-to-list 'exec-path "/home/nicolas/.local/bin")
  (use-package eglot-booster
            :after eglot
            :straight (:host github :repo "jdtsmith/eglot-booster" :branch "main")
            :config	(eglot-booster-mode))
#+end_src

#+RESULTS:
: t

Para o =eglot= funcionar corretamente, precisamos do =json-rpc=.
#+begin_src emacs-lisp :tangle init.el
  (use-package json-rpc)
#+end_src

#+RESULTS:

** =evil-mode=
Vou implementar o =evil-mode= como utilizado pelo =doom-emacs=, e
preciso configurar o mapa.
#+begin_src emacs-lisp :tangle init.el
  (use-package evil
   :init (setq evil-want-C-i-jump nil)
         (setq evil-want-C-u-scroll t)
         (evil-mode)
   :hook (delve-mode . turn-off-evil-mode))
  (evil-set-initial-state 'dired-mode 'emacs)
  (evil-set-initial-state 'vterm-mode 'emacs)
  (evil-set-initial-state 'delve-mode 'emacs)
  (use-package evil-surround
    :hook (evil-mode . evil-surround-mode))
  ;; (display-line-numbers-mode 1)
#+end_src

#+RESULTS:
| evil-surround-mode |

Para gerar o =keymap= com leader, posso usar o =general.el=
#+begin_src emacs-lisp :tangle init.el
  (use-package general
    :config (general-evil-setup t)
    (general-create-definer my/leader-keys
      :keymaps '(normal visual)
      :prefix "SPC"))
#+end_src

#+begin_src emacs-lisp :tangle init.el
  (my/leader-keys
    ;; file and buffer general usage
    "SPC" 'find-file 
    "RET" 'consult-bookmark
    "," 'consult-buffer
    "bb" 'ibuffer
    "bk" 'kill-buffer
    "bs" 'save-buffer
    "bl" 'next-buffer
    "bh" 'previous-buffer
    "." 'dired

    ;; commands
    "x" 'execute-extended-command
    ":" 'eval-expression
    ";" 'avy-goto-line

    ;; movement
    "TAB" 'other-window
    "s" 'avy-goto-char
    "/" 'consult-line
    "=" 'er/expand-region

    ;; ispell
    "$." 'flyspell-auto-correct-word
    "$b" 'ispell-buffer
    "$w" 'ispell-word

    ;; windows
    "w0" 'delete-window
    "w1" 'delete-other-windows
    "w2" 'split-and-follow-horizontally
    "w3" 'split-and-follow-vertically
    "wp" 'winner-undo
    "wn" 'winner-redo
    "w=" 'balance-windows
    "wt" 'transpose-frame
    "w TAB" 'ace-window

    ;; magit
    "gg" 'magit-status
    ;; "gb" 'magit-blame
    "gc" 'magit-commit
    "gC" 'magit-clone
    "gp" 'magit-push
    "gR" 'magit-revert
    "gs" 'magit-stage 
    "gx" 'magit-reset
    "gz" 'magit-stash

    ;; open general
    "om" 'notmuch
    "on" 'treemacs
    "ot" 'multi-vterm
    "of" 'find-file-other-window
    "o," 'consult-buffer-other-window

    ;; projectile
    "p!" 'projectile-run-shell-command-in-root
    "pf" 'projectile-find-file
    "pa" 'projectile-ag
    "p4f" 'projectile-find-file-other-window
    "pc" 'projectile-compile-project
    "pp" 'projectile-switch-project

    ;; help
    "hf" 'describe-function
    "hk" 'describe-key
    "hv" 'describe-variable
    "hd" 'eldoc

    ;; register
    "rs" 'consult-register-store
    "rl" 'consult-register-load
    "rr" 'consult-register

    ;; org roam
    "rf" 'org-roam-node-find
    "rc" 'org-roam-capture
    "rb" 'org-roam-buffer-toggle
    "rI" 'org-roam-node-insert-immediate
    "ri" 'org-roam-node-insert
    "ra" 'org-roam-alias-add
    "r]" 'org-roam-ref-find
    "rd" 'org-roam-dailies-goto-today
    "rg" 'org-roam-dailies-find-date

    ;; consult
    "cd" 'consult-find
    "cD" 'consult-locate
    "cg" 'consult-grep
    "cG" 'consult-git-grep
    "cr" 'consult-ripgrep
    "cl" 'consult-line

    ;; org ref
    "]" 'org-ref-insert-link
    ")" 'org-ref-insert-ref-link

    ;; snippets
    "yi" 'yas-insert-snippet
    "yn" 'yas-new-snippet
    "yv" 'yas-visit-snippet-file

    ;; agenda
    "aa" 'org-agenda
    "a[" 'org-agenda-file-to-front
    "a]" 'org-remove-file

    ;; store link
    "ls" 'org-store-link
    "li" 'org-insert-link

    ;; multiple cursors
    "@" 'evil-multiedit-toggle-marker-here
    "m@" 'evil-multiedit-match-all
    "mn" 'evil-multiedit-match-and-next
    "mp" 'evil-multiedit-match-and-prev

    ;; narrow
    "ns" 'org-narrow-to-subtree
    "nn" 'narrow-to-region
    "np" 'narrow-to-page
    "nd" 'narrow-to-defun
    "nw" 'widen

    ;; undo-tree
    "u" 'undo-tree-visualize

    ;; elfeed
    "ee" 'elfeed

    ;; org-babel
    "cc" 'org-ctrl-c-ctrl-c

    ;; other commands
    "ie" 'emoji-search
    "ip" 'paste-image
    "zz" 'zzz-to-char
    "ev" 'org-babel-tangle
    "ex" 'org-export-dispatch)
 #+end_src

#+RESULTS:

=evil-collection= é uma série de integrações do =evil-mode= com otras
coisas do emacs.
#+begin_src emacs-lisp :tangle init.el
  (use-package evil-collection
    :after evil
    :ensure t
    :config
    (evil-collection-init))
#+end_src

#+RESULTS:

** =elfeed=
Não estou usando muito o =elfeed= desde muito tempo, acho que posso
deixar de usar. Tenho que atualizar o feed se quiser voltar.
#+begin_src emacs-lisp :tangle init.el
  (use-package elfeed
    :config (setq elfeed-db-directory "~/.local/share/elfeed")
    :bind ("C-c e" . elfeed))

  (use-package elfeed-org
    :straight (:host github :repo "remyhonig/elfeed-org" :branch "master"))
  (elfeed-org)
  (setq rmh-elfeed-org-files (list "~/.config/emacs/private/org/elfeed.org"))
#+end_src

#+RESULTS:
| ~/.config/emacs/private/org/elfeed.org |


** =multiple-cursors=
Múltiplos cursores!
#+begin_src emacs-lisp :tangle init.el 
  (use-package multiple-cursors
    :ensure t
    :straight nil
    :bind (("C-S-c C-S-c" . mc/edit-lines) ;; add cursor to all selected lines
           ("C->" . mc/mark-next-like-this) ;; add cursor at the next ocurrence of selection on text
           ("C-<" . mc/mark-previous-like-this) ;; add cursor at the previous ocurrence of selection on text
           ("C-S-<mouse-1>" . mc/add-cursor-on-click)
           ("C-c C-<" . mc/mark-all-like-this)) ;;  add cursor at all ocurrences of selection on buffer
    :config (setq mc/cmds-to-run-once '()))
#+end_src
** COMMENT =obsidian.el= 
Com esse pacote, consigo acessar arquivos do obsidian direto do emacs
com maior integração. O ByMyCell armazena toda a documentação deles em obsidian.
#+begin_src emacs-lisp :tangle init.el
(use-package obsidian
  :ensure t
  :demand t
  :config
  (obsidian-specify-path "~/Documents/BMC/Documentação")
  (global-obsidian-mode t)
  :custom
  ;; This directory will be used for `obsidian-capture' if set.
  (obsidian-inbox-directory "Inbox")
  ;; Create missing files in inbox? - when clicking on a wiki link
  ;; t: in inbox, nil: next to the file with the link
  ;; default: t
  ;(obsidian-wiki-link-create-file-in-inbox nil)
  ;; The directory for daily notes (file name is YYYY-MM-DD.md)
  (obsidian-daily-notes-directory "Daily Notes")
  ;; Directory of note templates, unset (nil) by default
  ;(obsidian-templates-directory "Templates")
  ;; Daily Note template name - requires a template directory. Default: Daily Note Template.md
  ;(obsidian-daily-note-template "Daily Note Template.md")
  :bind (:map obsidian-mode-map
  ;; Replace C-c C-o with Obsidian.el's implementation. It's ok to use another key binding.
  ("C-c C-o" . obsidian-follow-link-at-point)
  ;; Jump to backlinks
  ("C-c C-b" . obsidian-backlink-jump)
  ;; If you prefer you can use `obsidian-insert-link'
  ("C-c C-l" . obsidian-insert-wikilink)))
#+end_src

#+RESULTS:
: obsidian-insert-wikilink
** =paste-image=
Com ajuda do ChatGPT, fiz uma breve extensão que salva uma imagem do
clipboard em um diretório do workdir, e insere o link a ela tanto em
org quanto em \(\LaTeX\).
#+begin_src emacs-lisp :tangle init.el
  (defun paste-image ()
    "Paste an image from the clipboard, save it in the current working directory, and insert a link to it in the buffer.
  The link format depends on the current major mode: Org-mode or LaTeX."
    (interactive)
    (let* ((directory default-directory)
           (filename (concat (make-temp-name (concat directory "img/")) ".png"))
           (command (concat "xclip -selection clipboard -t image/png -o | convert - " filename)))
      (shell-command command)
      (if (file-exists-p filename)
          (cond
           ((derived-mode-p 'org-mode)
            (insert (concat "[[file:" filename "]]"))
            (message "Saved image to %s and inserted Org link" filename))
           ((derived-mode-p 'latex-mode)
            (insert (format "\\begin{figure}[h]\n\\centering\n\\includegraphics[width=\\linewidth]{%s}\n\\caption{}\n\\label{fig:}\n\\end{figure}" filename))
            (message "Saved image to %s and inserted LaTeX figure" filename))
           (t
            (message "Current mode is neither Org-mode nor LaTeX-mode, saved image to %s" filename)))
        (message "Failed to save image"))))
#+end_src

#+RESULTS:
: paste-image

** =pdf-tools=
PDFs no emacs? Responsivos, bons e úteis? Sign me in!
#+begin_src emacs-lisp :tangle init.el 
  (use-package pdf-tools
    :hook (pdf-view-mode . blink-cursor-mode)
    :config (add-hook 'pdf-view-mode-hook 'auto-revert-mode)
    :config
    (define-key pdf-view-mode-map (kbd ":") 'pdf-view-goto-page)
    (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
    (define-key pdf-view-mode-map (kbd "C-r") 'isearch-backward)
    (define-key pdf-view-mode-map (kbd "/") 'isearch-forward)
    (define-key pdf-view-mode-map (kbd "?") 'isearch-backward)
    (define-key pdf-view-mode-map (kbd "j") 'pdf-view-next-line-or-next-page)
    (define-key pdf-view-mode-map (kbd "k") 'pdf-view-previous-line-or-previous-page)
    (define-key pdf-view-mode-map (kbd "l") 'image-forward-hscroll)
    (define-key pdf-view-mode-map (kbd "h") 'image-backward-hscroll)
    (define-key pdf-view-mode-map (kbd "J") 'pdf-view-next-page-command)
    (define-key pdf-view-mode-map (kbd "K") 'pdf-view-previous-page-command)
    (define-key pdf-view-mode-map (kbd "TAB") 'pdf-outline)
    (define-key pdf-view-mode-map (kbd "C-S-r") 'pdf-view-midnight-minor-mode)
    (define-key pdf-view-mode-map (kbd "T") 'pdf-view-themed-minor-mode)
    (define-key pdf-view-mode-map (kbd "s") 'pdf-view-fit-width-to-window)
    (define-key pdf-view-mode-map (kbd "a") 'pdf-view-fit-page-to-window)
    :config (setq pdf-view-midnight-colors '("#FFBB33" . "#222222")))
  (pdf-loader-install)
#+end_src

#+RESULTS:

** =rainbow-delimiter=
 Colore os delimitadores corretamente.
#+begin_src emacs-lisp :tangle init.el 
  (use-package rainbow-delimiters
    :init( progn (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
                 (add-hook 'LaTeX-mode-hook 'rainbow-delimiters-mode)))
#+end_src
** =rgrep=
Preciso instalar o =rgrep= no emacs para fazer uso do
=consult-ripgrep= ou =projectile-ripgrep=.
#+begin_src emacs-lisp :tangle init.el
  (use-package ripgrep)
#+end_src

** =smartparens=
Abre, fecha e acerta os parênteses automaticamente.
#+begin_src emacs-lisp :tangle init.el 
  (use-package smartparens
    :init (require 'smartparens-config)
    :init (smartparens-global-mode))
#+end_src
** =yasnippet=
Snippets para acelerar a escrita!
#+begin_src emacs-lisp :tangle init.el 
  (add-to-list 'load-path
               "~/.config/emacs/plugins/yasnippet")
  (use-package yasnippet
    :init (yas-global-mode))
  (use-package yasnippet-snippets)
  ;; (use-package ivy-yasnippet)
#+end_src
** =zzz-to-char=
/Zaps to ace-char/.
#+begin_src emacs-lisp :tangle init.el 
  (use-package zzz-to-char
    :bind (("M-z" . zzz-to-char)))
#+end_src

* language specifics
** LaTeX
Aqui vou colocar algumas coisas de LaTeX e mudar para outro lugar
depois. 
*** =latex-extra=
Adiciona comandos extras para o =LaTeX-mode=.
#+begin_src emacs-lisp :tangle init.el
(use-package latex-extra)
#+end_src

#+RESULTS:

*** =AUCTex=
AUCTex organiza algumas coisas extras para o compilador do LaTeX e
permite mais funções. Antes, estava *tudo* fora do =use-package=, vou
tentar deixar lá dentro. Se der pau, eu arrumo.
#+begin_src emacs-lisp :tangle init.el 
  (use-package auctex
    :init (require 'latex)
    :bind (:map LaTeX-mode-map
                ("C-S-e" . latex-math-from-calc)
  	      (:map org-mode-map
  		    ("C-S-e" . latex-math-from-calc)))
    :config
    ;; Format math as a Latex string with Calc
    (defun latex-math-from-calc ()
      "Evaluate `calc' on the contents of line at point."
      (interactive)
      (cond ((region-active-p)
             (let* ((beg (region-beginning))
                    (end (region-end))
                    (string (buffer-substring-no-properties beg end)))
               (kill-region beg end)
               (insert (calc-eval `(,string calc-language latex
                                            calc-prefer-frac t
                                            calc-angle-mode rad)))))
            (t (let ((l (thing-at-point 'line)))
                 (end-of-line 1) (kill-line 0) 
                 (insert (calc-eval `(,l
                                      calc-language latex
                                      calc-prefer-frac t
                                      calc-angle-mode rad)))))))
    :config (setq TeX-auto-save t)
    (setq TeX-parse-self t)
    (setq-default TeX-master nil)
    (setq font-latex-fontify-script nil))
#+end_src

#+RESULTS:
: latex-math-from-calc

*** =ReFTeX=
ReFTeX adiciona /keybinds/ para referências em LaTeX.
#+begin_src emacs-lisp :tangle init.el 
  (use-package reftex
    :config (setq reftex-plug-into-AUCTeX t)
            (setq prettify-symbols-unprettify-at-point 'right-edge)
    :hook (TeX-mode . prettify-symbols-mode)
          (LaTeX-mode . LaTeX-math-mode)
          (TeX-mode . outline-minor-mode)
          (TeX-mode . turn-on-reftex))
#+end_src

#+RESULTS:
| turn-on-reftex | outline-minor-mode | prettify-symbols-mode |

Adições para o =LaTeX-math=.
#+begin_src emacs-lisp :tangle init.el
  (define-key LaTeX-math-mode-map (kbd "` o *") 'LaTeX-math-otimes)
  (define-key LaTeX-math-mode-map (kbd "` o .") 'LaTeX-math-odot)
  (defun LaTeX-math-mathcal (key dol)
    (interactive "*c\nP")
    (insert (format "\\mathcal{%s}" (char-to-string key))))
  (define-key LaTeX-math-mode-map (kbd "` c") 'LaTeX-math-mathcal)
#+end_src

*** TODO =lazytab=
=lazytab= é capaz de criar matrizes, em LaTeX, utilizando =TAB= e a
sintaxe de =org-mode=. Pode precisar de conserto.
#+begin_src emacs-lisp :tangle init.el
  (use-package lazytab
    :straight (:host github :repo  "karthink/lazytab" :branch "master")
    :hook ((LaTeX-mode . lazytab-mode) (LaTeX-math-mode . orgtbl-mode)))
#+end_src

** =julia=
#+begin_src emacs-lisp :tangle init.el
  (use-package julia-repl)
  (use-package julia-mode
    :mode ("\\.jl\\'" . julia-mode)
    :interpreter ("julia" . julia-mode)
    :bind
    (:map julia-mode-map
          ("C-c C-z" . julia-repl)
          ("C-c C-c" . julia-repl-send-buffer)
          ("C-<return>" . julia-repl-send-region-or-line)
          ("C-<enter>" . julia-repl-send-region-or-line)
          ("C-c C-d" . julia-repl-doc)))
#+end_src

** =ledger=
=ledger= é onde eu guardo todas as minhas finanças organizadas. É
realmente um baita software.
#+begin_src emacs-lisp :tangle init.el 
  (use-package ledger-mode
    :config (progn (setq ledger-reports
                         (quote
                          (("bal cf" "%(binary) -f %(ledger-file) bal ^Income ^Expenses --real")
                           ("bal nw" "%(binary) -f %(ledger-file) bal ^Assets ^Liabilities --real")
                           ("bal precos" "%(binary) -f %(ledger-file) --price-db btc_price.db --price-db comm.db -V bal")
                           ("bal" "%(binary) -f %(ledger-file) bal")
                           ("reg" "%(binary) -f %(ledger-file) reg")
                           ("reg - price" "%(binary) -f %(ledger-file) reg -V --price-db btc_price.db --price-db comm.db")
                           ("payee" "%(binary) -f %(ledger-file) reg @%(payee)")
                           ("account" "%(binary) -f %(ledger-file) reg %(account)")))))
    :config (setq ledger-post-amount-alignment-column 60)
    :hook (ledger-mode . 
                       (lambda ()
                         (setq-local tab-always-indent 'complete)
                         (setq-local completion-ignore-case t)
                         (setq-local ledger-complete-in-steps t))))
#+end_src

** =nextflow=
No trabalho, talvez seja necessário o uso do [[id:feb39559-bb9d-4c86-88d9-1c6c5ff28e07][Nextflow]], que é uma
linguagem que cria pipelines, útil para desenvolvimento de ciência
reprodutível. 

#+begin_src emacs-lisp :tangle init.el
  (use-package groovy-mode) ;; requisito
  (use-package nextflow-mode
    :mode "\\.nf\\'" 
    :straight (:host github
  		   :repo "edmundmiller/nextflow-mode"
  		   :branch "master"))
#+end_src

#+RESULTS:
: ((\.py\' . python-mode) (\nextflow.config\' . nextflow-mode) (\.nextflow\' . nextflow-mode) (\.nf.test\' . nextflow-mode) (\.nf\' . nextflow-mode) (\.\(?:nf\)?patterns\' . nextflow-mode) (/Jenkinsfile\' . groovy-mode) (\.g\(?:ant\|roovy\|radle\)\' . groovy-mode) (\.ledger\' . ledger-mode) (\.jl\' . julia-mode) (\.hva\' . latex-mode) (\.[pP][dD][fF]\' closure ((args nil nil nil nil)) nil (apply #'pdf-loader--load args)) (/git-rebase-todo\' . git-rebase-mode) (\.editorconfig\' . editorconfig-conf-mode) (\.odc\' . archive-mode) (\.odf\' . archive-mode) (\.odi\' . archive-mode) (\.otp\' . archive-mode) (\.odp\' . archive-mode) (\.otg\' . archive-mode) (\.odg\' . archive-mode) (\.ots\' . archive-mode) (\.ods\' . archive-mode) (\.odm\' . archive-mode) (\.ott\' . archive-mode) (\.odt\' . archive-mode) (\.at\' . autotest-mode) (\.ipynb\' . ein:ipynb-mode) (\.\(?:md\|markdown\|mkd\|mdown\|mkdn\|mdwn\)\' . markdown-mode) (\.gpg\(~\|\.~[0-9]+~\)?\' nil epa-file) (\.elc\' . elisp-byte-code-mode) (\.zst\' nil jka-compr) (\.dz\' nil jka-compr) (\.xz\' nil jka-compr) (\.lzma\' nil jka-compr) (\.lz\' nil jka-compr) (\.g?z\' nil jka-compr) (\.bz2\' nil jka-compr) (\.Z\' nil jka-compr) (\.vr[hi]?\' . vera-mode) (\(?:\.\(?:rbw?\|ru\|rake\|thor\|jbuilder\|rabl\|gemspec\|podspec\)\|/\(?:Gem\|Rake\|Cap\|Thor\|Puppet\|Berks\|Brew\|Vagrant\|Guard\|Pod\)file\)\' . ruby-mode) (\.re?st\' . rst-mode) (\.py[iw]?\' . python-mode) (\.m\' . octave-maybe-mode) (\.less\' . less-css-mode) (\.scss\' . scss-mode) (\.cs\' . csharp-mode) (\.awk\' . awk-mode) (\.\(u?lpc\|pike\|pmod\(\.in\)?\)\' . pike-mode) (\.idl\' . idl-mode) (\.java\' . java-mode) (\.m\' . objc-mode) (\.ii\' . c++-mode) (\.i\' . c-mode) (\.lex\' . c-mode) (\.y\(acc\)?\' . c-mode) (\.h\' . c-or-c++-mode) (\.c\' . c-mode) (\.\(CC?\|HH?\)\' . c++-mode) (\.[ch]\(pp\|xx\|\+\+\)\' . c++-mode) (\.\(cc\|hh\)\' . c++-mode) (\.\(bat\|cmd\)\' . bat-mode) (\.[sx]?html?\(\.[a-zA-Z_]+\)?\' . mhtml-mode) (\.svgz?\' . image-mode) (\.svgz?\' . xml-mode) (\.x[bp]m\' . image-mode) (\.x[bp]m\' . c-mode) (\.p[bpgn]m\' . image-mode) (\.tiff?\' . image-mode) (\.gif\' . image-mode) (\.png\' . image-mode) (\.jpe?g\' . image-mode) (\.webp\' . image-mode) (\.te?xt\' . text-mode) (\.[tT]e[xX]\' . tex-mode) (\.ins\' . tex-mode) (\.ltx\' . latex-mode) (\.dtx\' . doctex-mode) (\.org\' . org-mode) (\.dir-locals\(?:-2\)?\.el\' . lisp-data-mode) (\.eld\' . lisp-data-mode) (eww-bookmarks\' . lisp-data-mode) (tramp\' . lisp-data-mode) (/archive-contents\' . lisp-data-mode) (places\' . lisp-data-mode) (\.emacs-places\' . lisp-data-mode) (\.el\' . emacs-lisp-mode) (Project\.ede\' . emacs-lisp-mode) (\.\(scm\|sls\|sld\|stk\|ss\|sch\)\' . scheme-mode) (\.l\' . lisp-mode) (\.li?sp\' . lisp-mode) (\.[fF]\' . fortran-mode) (\.for\' . fortran-mode) (\.p\' . pascal-mode) (\.pas\' . pascal-mode) (\.\(dpr\|DPR\)\' . delphi-mode) (\.\([pP]\([Llm]\|erl\|od\)\|al\)\' . perl-mode) (Imakefile\' . makefile-imake-mode) (Makeppfile\(?:\.mk\)?\' . makefile-makepp-mode) (\.makepp\' . makefile-makepp-mode) (\.mk\' . makefile-gmake-mode) (\.make\' . makefile-gmake-mode) ([Mm]akefile\' . makefile-gmake-mode) (\.am\' . makefile-automake-mode) (\.texinfo\' . texinfo-mode) (\.te?xi\' . texinfo-mode) (\.[sS]\' . asm-mode) (\.asm\' . asm-mode) (\.css\' . css-mode) (\.mixal\' . mixal-mode) (\.gcov\' . compilation-mode) (/\.[a-z0-9-]*gdbinit . gdb-script-mode) (-gdb\.gdb . gdb-script-mode) ([cC]hange\.?[lL]og?\' . change-log-mode) ([cC]hange[lL]og[-.][0-9]+\' . change-log-mode) (\$CHANGE_LOG\$\.TXT . change-log-mode) (\.scm\.[0-9]*\' . scheme-mode) (\.[ckz]?sh\'\|\.shar\'\|/\.z?profile\' . sh-mode) (\.bash\' . sh-mode) (/PKGBUILD\' . sh-mode) (\(/\|\`\)\.\(bash_\(profile\|history\|log\(in\|out\)\)\|z?log\(in\|out\)\)\' . sh-mode) (\(/\|\`\)\.\(shrc\|zshrc\|m?kshrc\|bashrc\|t?cshrc\|esrc\)\' . sh-mode) (\(/\|\`\)\.\([kz]shenv\|xinitrc\|startxrc\|xsession\)\' . sh-mode) (\.m?spec\' . sh-mode) (\.m[mes]\' . nroff-mode) (\.man\' . nroff-mode) (\.sty\' . latex-mode) (\.cl[so]\' . latex-mode) (\.bbl\' . latex-mode) (\.bib\' . bibtex-mode) (\.bst\' . bibtex-style-mode) (\.sql\' . sql-mode) (\(acinclude\|aclocal\|acsite\)\.m4\' . autoconf-mode) (\.m[4c]\' . m4-mode) (\.mf\' . metafont-mode) (\.mp\' . metapost-mode) (\.vhdl?\' . vhdl-mode) (\.article\' . text-mode) (\.letter\' . text-mode) (\.i?tcl\' . tcl-mode) (\.exp\' . tcl-mode) (\.itk\' . tcl-mode) (\.icn\' . icon-mode) (\.sim\' . simula-mode) (\.mss\' . scribe-mode) (\.f9[05]\' . f90-mode) (\.f0[38]\' . f90-mode) (\.indent\.pro\' . fundamental-mode) (\.\(pro\|PRO\)\' . idlwave-mode) (\.srt\' . srecode-template-mode) (\.prolog\' . prolog-mode) (\.tar\' . tar-mode) (\.\(arc\|zip\|lzh\|lha\|zoo\|[jew]ar\|xpi\|rar\|cbr\|7z\|squashfs\|ARC\|ZIP\|LZH\|LHA\|ZOO\|[JEW]AR\|XPI\|RAR\|CBR\|7Z\|SQUASHFS\)\' . archive-mode) (\.oxt\' . archive-mode) (\.\(deb\|[oi]pk\)\' . archive-mode) (\`/tmp/Re . text-mode) (/Message[0-9]*\' . text-mode) (\`/tmp/fol/ . text-mode) (\.oak\' . scheme-mode) (\.sgml?\' . sgml-mode) (\.x[ms]l\' . xml-mode) (\.dbk\' . xml-mode) (\.dtd\' . sgml-mode) (\.ds\(ss\)?l\' . dsssl-mode) (\.js[mx]?\' . javascript-mode) (\.har\' . javascript-mode) (\.json\' . js-json-mode) (\.[ds]?va?h?\' . verilog-mode) (\.by\' . bovine-grammar-mode) (\.wy\' . wisent-grammar-mode) (\.erts\' . erts-mode) ([:/\]\..*\(emacs\|gnus\|viper\)\' . emacs-lisp-mode) (\`\..*emacs\' . emacs-lisp-mode) ([:/]_emacs\' . emacs-lisp-mode) (/crontab\.X*[0-9]+\' . shell-script-mode) (\.ml\' . lisp-mode) (\.ld[si]?\' . ld-script-mode) (ld\.?script\' . ld-script-mode) (\.xs\' . c-mode) (\.x[abdsru]?[cnw]?\' . ld-script-mode) (\.zone\' . dns-mode) (\.soa\' . dns-mode) (\.asd\' . lisp-mode) (\.\(asn\|mib\|smi\)\' . snmp-mode) (\.\(as\|mi\|sm\)2\' . snmpv2-mode) (\.\(diffs?\|patch\|rej\)\' . diff-mode) (\.\(dif\|pat\)\' . diff-mode) (\.[eE]?[pP][sS]\' . ps-mode) (\.\(?:PDF\|EPUB\|CBZ\|FB2\|O?XPS\|DVI\|OD[FGPST]\|DOCX\|XLSX?\|PPTX?\|pdf\|epub\|cbz\|fb2\|o?xps\|djvu\|dvi\|od[fgpst]\|docx\|xlsx?\|pptx?\)\' . doc-view-mode-maybe) (configure\.\(ac\|in\)\' . autoconf-mode) (\.s\(v\|iv\|ieve\)\' . sieve-mode) (BROWSE\' . ebrowse-tree-mode) (\.ebrowse\' . ebrowse-tree-mode) (#\*mail\* . mail-mode) (\.g\' . antlr-mode) (\.mod\' . m2-mode) (\.ses\' . ses-mode) (\.docbook\' . sgml-mode) (\.com\' . dcl-mode) (/config\.\(?:bat\|log\)\' . fundamental-mode) (/\.\(authinfo\|netrc\)\' . authinfo-mode) (\.\(?:[iI][nN][iI]\|[lL][sS][tT]\|[rR][eE][gG]\|[sS][yY][sS]\)\' . conf-mode) (\.la\' . conf-unix-mode) (\.ppd\' . conf-ppd-mode) (java.+\.conf\' . conf-javaprop-mode) (\.properties\(?:\.[a-zA-Z0-9._-]+\)?\' . conf-javaprop-mode) (\.toml\' . conf-toml-mode) (\.desktop\' . conf-desktop-mode) (/\.redshift\.conf\' . conf-windows-mode) (\`/etc/\(?:DIR_COLORS\|ethers\|.?fstab\|.*hosts\|lesskey\|login\.?de\(?:fs\|vperm\)\|magic\|mtab\|pam\.d/.*\|permissions\(?:\.d/.+\)?\|protocols\|rpc\|services\)\' . conf-space-mode) (\`/etc/\(?:acpid?/.+\|aliases\(?:\.d/.+\)?\|default/.+\|group-?\|hosts\..+\|inittab\|ksysguarddrc\|opera6rc\|passwd-?\|shadow-?\|sysconfig/.+\)\' . conf-mode) ([cC]hange[lL]og[-.][-0-9a-z]+\' . change-log-mode) (/\.?\(?:gitconfig\|gnokiirc\|hgrc\|kde.*rc\|mime\.types\|wgetrc\)\' . conf-mode) (/\.mailmap\' . conf-unix-mode) (/\.\(?:asound\|enigma\|fetchmail\|gltron\|gtk\|hxplayer\|mairix\|mbsync\|msmtp\|net\|neverball\|nvidia-settings-\|offlineimap\|qt/.+\|realplayer\|reportbug\|rtorrent\.\|screen\|scummvm\|sversion\|sylpheed/.+\|xmp\)rc\' . conf-mode) (/\.\(?:gdbtkinit\|grip\|mpdconf\|notmuch-config\|orbital/.+txt\|rhosts\|tuxracer/options\)\' . conf-mode) (/\.?X\(?:default\|resource\|re\)s\> . conf-xdefaults-mode) (/X11.+app-defaults/\|\.ad\' . conf-xdefaults-mode) (/X11.+locale/.+/Compose\' . conf-colon-mode) (/X11.+locale/compose\.dir\' . conf-javaprop-mode) (\.~?[0-9]+\.[0-9][-.0-9]*~?\' nil t) (\.\(?:orig\|in\|[bB][aA][kK]\)\' nil t) ([/.]c\(?:on\)?f\(?:i?g\)?\(?:\.[a-zA-Z0-9._-]+\)?\' . conf-mode-maybe) (\.[1-9]\' . nroff-mode) (\.art\' . image-mode) (\.avs\' . image-mode) (\.bmp\' . image-mode) (\.cmyk\' . image-mode) (\.cmyka\' . image-mode) (\.crw\' . image-mode) (\.dcr\' . image-mode) (\.dcx\' . image-mode) (\.dng\' . image-mode) (\.dpx\' . image-mode) (\.fax\' . image-mode) (\.heic\' . image-mode) (\.hrz\' . image-mode) (\.icb\' . image-mode) (\.icc\' . image-mode) (\.icm\' . image-mode) (\.ico\' . image-mode) (\.icon\' . image-mode) (\.jbg\' . image-mode) (\.jbig\' . image-mode) (\.jng\' . image-mode) (\.jnx\' . image-mode) (\.miff\' . image-mode) (\.mng\' . image-mode) (\.mvg\' . image-mode) (\.otb\' . image-mode) (\.p7\' . image-mode) (\.pcx\' . image-mode) (\.pdb\' . image-mode) (\.pfa\' . image-mode) (\.pfb\' . image-mode) (\.picon\' . image-mode) (\.pict\' . image-mode) (\.rgb\' . image-mode) (\.rgba\' . image-mode) (\.tga\' . image-mode) (\.wbmp\' . image-mode) (\.webp\' . image-mode) (\.wmf\' . image-mode) (\.wpg\' . image-mode) (\.xcf\' . image-mode) (\.xmp\' . image-mode) (\.xwd\' . image-mode) (\.yuv\' . image-mode) (\.tgz\' . tar-mode) (\.tbz2?\' . tar-mode) (\.txz\' . tar-mode) (\.tzst\' . tar-mode) (\.drv\' . latex-mode))

** =notmuch=
Cliente de email.
#+begin_src emacs-lisp :tangle init.el 
  (use-package notmuch
    :bind ("C-c m" . notmuch))
#+end_src

#+RESULTS:
: notmuch


Algumas configurações importantes para enviar email.
#+begin_src emacs-lisp :tangle init.el 
  (setq
   send-mail-function 'smtpmail-send-it
   message-send-mail-function 'smtpmail-send-it
   user-mail-address "nicolas.morazotti@gmail.com"
   smtpmail-starttls-credentials '(("smtp.gmail.com" "587" nil nil))
   smtpmail-default-smtp-server "smtp.gmail.com"
   smtpmail-smtp-server "smtp.gmail.com"
   smtpmail-smtp-service 587
   smtpmail-debug-info t
   starttls-extra-arguments nil
   starttls-gnutls-program "/usr/bin/gnutls-cli"
   starttls-extra-arguments nil
   starttls-use-gnutls t)
#+end_src

Arquivo de assinatura de email.
#+begin_src emacs-lisp :tangle init.el 
(setq message-signature-file "~/.config/emacs/private/signature")
#+end_src

Para pegar links de email e jogar pro =org=, é só digitar =c i=.
#+begin_src emacs-lisp :tangle no
(org-link-set-parameters "notmuch"
			 :follow 'org-notmuch-open
			 :store 'org-notmuch-store-link)

(defun org-notmuch-open (id)
  "Visit the notmuch message or thread with id ID."
  (notmuch-show id))

(defun org-notmuch-store-link ()
  "Store a link to a notmuch mail message."
  (cl-case major-mode
    ('notmuch-show-mode
     ;; Store link to the current message
     (let* ((id (notmuch-show-get-message-id))
	    (link (concat "notmuch:" id))
	    (description (format "Mail: %s" (notmuch-show-get-subject))))
       (org-store-link-props
	:type "notmuch"
	:link link
	:description description)))
    ('notmuch-search-mode
     ;; Store link to the thread on the current line
     (let* ((id (notmuch-search-find-thread-id))
	    (link (concat "notmuch:" id))
	    (description (format "Mail: %s" (notmuch-search-find-subject))))
       (org-store-link-props
	:type "notmuch"
	:link link
	:description description)))))
    
(provide 'org-notmuch)
#+end_src

** =python=
Para utilizar o interpretador correto, adicionamos isso aqui.
#+begin_src emacs-lisp :tangle init.el
  (use-package python-mode
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("python" . python-mode))
#+end_src

Aqui, vamos importar o =python-black=, que é um linter de código
python, para deixá-lo ao máximo seguindo a PEP8.
#+begin_src emacs-lisp :tangle init.el
  (use-package python-black)
#+end_src

Vamos utilizar também o modo de ambiente virtual do python, =pyvenv=.
#+begin_src emacs-lisp :tangle init.el
  ;; check if pyvenv is enabled
  ;; create a y/n question to use pyvenv whenever opening python files 
  (defun use-pyvenv ()
    (interactive)
    (unless (bound-and-true-p pyvenv-virtual-env)
        (if (y-or-n-p "Use pyvenv? ")
            (pyvenv-activate (read-directory-name "Enter virtualenv directory: " "~/.anaconda3/envs/" nil nil)))))

  (use-package pyvenv
    :hook (python-mode . pyvenv-mode)
    :hook (python-mode . use-pyvenv)
    )
#+end_src

#+RESULTS:
| my-prompt-auto-activate-pyvenv | use-pyvenv | pyvenv-mode | eglot-ensure | doom-modeline-env-setup-python |
